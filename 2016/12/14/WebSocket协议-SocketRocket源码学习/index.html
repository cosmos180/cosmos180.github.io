<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> WebSocket协议、SocketRocket源码学习 · bug world</title><meta name="description" content="WebSocket协议、SocketRocket源码学习 - bug小英雄"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://antyme.com/atom.xml" title="bug world"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.jpeg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/cosmos180" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">WebSocket协议、SocketRocket源码学习</h1><div class="post-info">Dec 14, 2016</div><div class="post-content"><p><a href="https://tools.ietf.org/html/rfc6455#section-5.5.1" target="_blank" rel="external">rfc6455 WebSockets 标准</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/WebSockets/Writing_WebSocket_servers" target="_blank" rel="external">编写 WebSocket 服务器</a></p>
<h3 id="WebSocket概述、握手"><a href="#WebSocket概述、握手" class="headerlink" title="WebSocket概述、握手"></a>WebSocket概述、握手</h3><p>首先，服务器必须通过标准 TCP 套接字来侦听外来的连接请求。取决于你的平台，可能已经处理好握手了。举个例子，我们假定你的服务监听在地址 example.com ，端口号 8000 上，而且能够回应路径 /chat 上的 GET 请求。</p>
<blockquote>
<p>警告: 服务器监听任意所选择的端口，但是如果在 80 或者 443 之外的端口上，可能会在防火墙或者代理上出问题。在 443 端口上比较容易成功，但是需要安全连接（TLS/SSL）。另外就是大多数浏览器（比如 Firefox 8+）不允许在安全页面上连接不安全的 WebSocket 服务器。</p>
</blockquote>
<p>握手这一环节就是 WebSockets 上的“web”。它是从 HTTP 到 WS 的桥梁。握手时会协商连接的详细信息，并且如果条件不适合，任何一方都可以在成功建立连接之前退出。服务器一定要清楚客户端所要求的一切信息，否则可能会发生安全问题。</p>
<h5 id="客户端握手请求"><a href="#客户端握手请求" class="headerlink" title="客户端握手请求"></a>客户端握手请求</h5><p>即使你正在构建一个服务，WebSocket 握手请求仍需要由客户端发起。因此你必须知道如何解读客户端信息。首先客户端会发送类似这样的标准 HTTP 请求（HTTP 版本号最低为 1.1 ，而且请求方法必须为 GET）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">GET /chat HTTP/1.1</div><div class="line">Host: example.com:8000</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</div><div class="line">Sec-WebSocket-Version: 13</div></pre></td></tr></table></figure>
<p>客户端可以请求扩展和/或子协议化，详见<a href="https://developer.mozilla.org/zh-CN/docs/WebSockets/Writing_WebSocket_servers#Miscellaneous" target="_blank" rel="external">杂项</a>。另外，常规的头部信息如User-Agent,Referer, Cookie, or authentication 等也可能会出现。你可以随意处理这些内容，它们并不直接属于WebScoket的一部分，忽略它们也没事。在许多的常见设置中，反向代理已经对它们进行了处理。</p>
<p>如果存在任何未知或者错误的请求头，服务器应该发送一个 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#400" target="_blank" rel="external">“400 Bad Request”</a>并立即关闭 socket。像往常一样，也可以在HTTP响应体中给出握手失败的原因，但是这个消息可能从来都不会显示出来 (浏览器不显示)。 如果服务器无法理解请求的WebSockets的版本，它应该发送一个包含它能理解的版本号的Sec-WebSocket-Version的头部信息。 (本指南解释了最新版本的v13)。现在让我们来了解一下最让人期待的头部信息，Sec-WebSocket-Key。</p>
<blockquote>
<p><em>提示: 所有的浏览器都会发送 Origin 请求头，你可以用它来处理安全问题（比如黑名单，白名单，origin检查之类的）然后发送回去 403 Forbidden 来禁止连接。但是要注意，非浏览器客户端可以发送伪造的 Origin。大多数应用如果没有检测到 Origin 请求头将会拒绝请求。</em></p>
<p><em>提示: 请求地址 (例如这里是 /chat ) 在规范中没有明确定义。所以许多人巧妙的利用这点，让一个服务器处理多个 WebSocket 应用。例如在 example.com/chat 上是一个聊天室，与此同时在 /game 上运行一个多人联机游戏。</em></p>
<p><em>注意: 常规 HTTP 状态码 只能在握手前使用。握手成功后，你就得用不同的代码了 (参阅规范的第7章第4节 ).</em></p>
</blockquote>
<h5 id="服务器握手响应"><a href="#服务器握手响应" class="headerlink" title="服务器握手响应"></a>服务器握手响应</h5><p>服务器收到握手请求后，就应该发送一个看起来很怪异 (但是仍然是 HTTP ) 的响应，就像这样：(记得每一个响应头之间用 \r\n 间隔，最后再放一个 \r\n 空行)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 101 Switching Protocols</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</div></pre></td></tr></table></figure>
<p>此外，服务器在这里也可以指明 扩展/子协议，具体参考 杂项。其中的 Sec-WebSocket-Accept 比较有意思。要生成它，将客户端提供的 Sec-WebSocket-Key 和规定中指明的 魔法字符串 “258EAFA5-E914-47DA-95CA-C5AB0DC85B11” 简单地连在一起，进行 SHA-1 Hash，然后用 base64 编码，返回结果即可。</p>
<blockquote>
<p>仅供参考: 这个过程对于判断服务器是否支持WebSockets这个很明显的事情来说可能显得太过复杂。但是，这非常重要，如果服务器接受了一个WebSockets的链接却按照HTTP请求来解析可能会带来安全上的问题。</p>
</blockquote>
<p>所以假设客户端发来的是 “dGhlIHNhbXBsZSBub25jZQ==”，服务器就回复 “s3pPLMBiTxaQ9kYGzzhZRbK+xOo=”。一旦服务器发送完这些响应头，连接就建立了，可以开始交换数据了。</p>
<blockquote>
<p>当然服务器也可以发送 Set-Cookie 之类的头，或者关于认证的请求，或者通过其他状态码重定向，总之只要在握手响应信息发出之前都可以。</p>
</blockquote>
<h5 id="持续追踪客户端"><a href="#持续追踪客户端" class="headerlink" title="持续追踪客户端"></a>持续追踪客户端</h5><p>这部分和Websocket协议没有直接关系，但请务必注意：你的服务器必须持续追踪每个客户端的socket以避免进行重复的握手。同一个客户IP地址可能尝试连接多次（但服务器为保护自己免受DoS拒绝服务式攻击，也可拒绝那些过多请求连接的客户端）。</p>
<h3 id="WebSocket协议"><a href="#WebSocket协议" class="headerlink" title="WebSocket协议"></a>WebSocket协议</h3><blockquote>
<p>我们知道客户端和服务端都能在任意时候发送数据——这是WebSocket的神奇之处，而且不管数据是从客户端-&gt;服务端，还是从服务端-&gt;客户端，每个数据帧（包）的格式都是一样的，如下表所示：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">0                   1                   2                   3</div><div class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</div><div class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</div><div class="line">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</div><div class="line">|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</div><div class="line">|N|V|V|V|       |S|             |   (if payload len==126/127)   |</div><div class="line">| |1|2|3|       |K|             |                               |</div><div class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</div><div class="line">|     Extended payload length continued, if payload len == 127  |</div><div class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</div><div class="line">|                               |Masking-key, if MASK set to 1  |</div><div class="line">+-------------------------------+-------------------------------+</div><div class="line">| Masking-key (continued)       |          Payload Data         |</div><div class="line">+-------------------------------- - - - - - - - - - - - - - - - +</div><div class="line">:                     Payload Data continued ...                :</div><div class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</div><div class="line">|                     Payload Data continued ...                |</div><div class="line">+---------------------------------------------------------------+</div><div class="line"></div><div class="line">		websocket协议（数据帧格式）</div></pre></td></tr></table></figure>
<blockquote>
<p>1、字段FIN：FIN 位和操作码字段共同起到把一个报文分成几个数据帧发送的作用。这就叫做报文分段，分段只在操作码为 0x0、0x1、0x2 时有效。下面demo-1详细介绍其用法。</p>
<p>2、字段RSV1、RSV2、RSV3可忽略，那是用于扩展的保留字段。</p>
<p>3、字段opcode：操作码(opcode) 字段定义怎样解释负载数据： 字段定义了如何解释有效负载数据:  0x0 为继续，0x1 文本 (以 utf-8 编码)，0x2 为二进制数据，和后面将要讨论的其他所谓”控制代码”。在此版本的 Websocket（当前版本号为13），0x3 到 0x7 和 0xB 到 0xF 无意义。<br><br></p>
<ul>
<li>0x00：表示这帧是连续的帧，应该把这帧的负载数据连接到接收的上一帧，下面demo1描述了具体的用法。<br><br></li>
<li>0x01：负载数据是文本。<br><br></li>
<li>0x02：负载数据是二进制数据。<br><br></li>
<li>0x08：关闭连接的请求帧，要关闭一个连接的话，客户端或者服务端可以发送一个带有一段特殊控制序列数据的控制帧，来开始挥手过程。一旦接收到这样的帧，另一方发送关闭帧作为回应。任何关闭连接之后的数据将被废弃。（我在调试的时候这个值等于’\b’，知道为什么吗😝）<br><br></li>
<li>0x9：Ping包，在握手后的任何一个时间点，客户端或者服务器可以选择发送一个ping包给对方。<br> <br></li>
<li>0xA：Pong包，当ping包被收到时，接受者必须尽可能快的发回pong包。例如，你可以使用这个机制来确定客户端仍然处于连接状态。</li>
</ul>
<p>4、字段MASK：MASK字段表明报文是否被编码（按：即前述XOR异或加密）。客户端发来的消息应该被掩蔽，所以你的服务器应该期待这个位为1。（事实上，<a href="https://tools.ietf.org/html/rfc6455#section-5.1节" target="_blank" rel="external">rfc6455 websocket规范的5.1</a>说如客户端发来“未掩蔽”的报文那服务端应该断开这个连接。）服务端回报文给客户端则不要掩蔽数据，相应的MASK位为0。稍后我们将解释掩蔽。注意：即使在一个安全套接字上传输数据，也要遵守上述规则。</p>
<p>5、字段Payload len（9-15位）：读取负载数据，需要知道读到那里为止。因此获知负载数据长度很重要。这个过程稍微有点复杂，要以下这些步骤：</p>
<ul>
<li>读取9-15位 (包括9和15位本身)，并转换为无符号整数。如果值小于或等于125，这个值就是长度；如果是 126，请转到步骤 2。如果它是 127，请转到步骤 3。</li>
<li>读取接下来的 16 位并转换为无符号整数，并作为长度。</li>
<li>读取接下来的 64 位并转换为无符号整数 (最高有效位必须为0)，并作为长度。</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Client: FIN=1, opcode=0x1, msg=&quot;hello&quot;</div><div class="line">Server: (process complete message immediately) Hi.</div><div class="line">Client: FIN=0, opcode=0x1, msg=&quot;and a&quot;</div><div class="line">Server: (listening, new message containing text started)</div><div class="line">Client: FIN=0, opcode=0x0, msg=&quot;happy new&quot;</div><div class="line">Server: (listening, payload concatenated to previous message)</div><div class="line">Client: FIN=1, opcode=0x0, msg=&quot;year!&quot;</div><div class="line">Server: (process complete message) Happy new year to you too!</div><div class="line"></div><div class="line">				demo-1</div></pre></td></tr></table></figure>
<p>demo-1描述服务器如何回应客户端发送的文本数据。第一个报文发送了单个数据帧，而第二个报文通过三帧发送。</p>
<h3 id="WebSocket-iOS开源库SocketRocket源码学习（facebook）"><a href="#WebSocket-iOS开源库SocketRocket源码学习（facebook）" class="headerlink" title="WebSocket iOS开源库SocketRocket源码学习（facebook）"></a>WebSocket iOS开源库SocketRocket源码学习（<a href="https://github.com/facebook/SocketRocket" target="_blank" rel="external">facebook</a>）</h3><p>所有学习方法中有一条比较高效的就是理论联系实际（代码）。iOS开发中用的比较多的是websocket库是Socket.IO-Client-Swift和Facebook开源的SocketRocket，刚开始准备研究学习第一个，发现Socket.IO-Client与我们自己服务端提供的接口适配有点问题，而且看了下源代码，默认会在path后面强制插入’/‘，而且请求的path也会强制处理，没有提供自定义的机会，搞了一上午都连不上。在继续之前尝试了一下SocketRocket，哇塞，不要太爽，不愧是Facebook啊！于是立即“悬崖勒马”，用这篇文章记录下自己的收获和理解。</p>
<p>下面的代码片段来自于SocketRocket源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (void)_initializeStreams;</div><div class="line">&#123;</div><div class="line">    assert(_url.port.unsignedIntValue &lt;= UINT32_MAX);</div><div class="line">    uint32_t port = _url.port.unsignedIntValue;</div><div class="line">    if (port == 0) &#123;</div><div class="line">        if (!_secure) &#123;</div><div class="line">            port = 80;</div><div class="line">        &#125; else &#123;</div><div class="line">            port = 443;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    NSString *host = _url.host;</div><div class="line">    </div><div class="line">    CFReadStreamRef readStream = NULL;</div><div class="line">    CFWriteStreamRef writeStream = NULL;</div><div class="line">    </div><div class="line">    CFStreamCreatePairWithSocketToHost(NULL, (__bridge CFStringRef)host, port, &amp;readStream, &amp;writeStream);//创建了socket通信的输入和输出流</div><div class="line">    </div><div class="line">    _outputStream = CFBridgingRelease(writeStream);</div><div class="line">    _inputStream = CFBridgingRelease(readStream);</div><div class="line">    </div><div class="line">    //@protocol NSStreamDelegate &lt;NSObject&gt;</div><div class="line">	//	@optional</div><div class="line">	//	- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode;</div><div class="line">	// @end</div><div class="line">    _inputStream.delegate = self;</div><div class="line">    _outputStream.delegate = self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>_initializeStreams方法创建了socket通信的输入和输出stream。但是，请看Apple文档对CFStreamCreatePairWithSocketToHost方法的说明，很重要。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Creates readable and writable streams connected to a TCP/IP port of a particular host.</div><div class="line">The streams do not create a socket, resolve the hostname, or connect to the remote host until you open one of the streams.</div><div class="line">Most properties are shared by both streams. Setting a shared property for one stream automatically sets the property for the other.</div></pre></td></tr></table></figure>
<blockquote>
<p>我大致翻译一下（尴尬）：这个方法在本机与使用TCP/IP端口的对方主机之间仅仅创建了用来写入和读取数据的两个流。但是这些流并没有创建真正的socket，没有开始解析这个host，也没有开始连接对方主机，上述这些操作会在调用open的时候执行。这两个流会共享大多数的属性。只要修改的属性恰好是它们共享的，在它们任何一个中进行修改，都会自动把该属性修改之后的值同步给另外一方。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)openConnection;</div><div class="line">&#123;</div><div class="line">    [self _updateSecureStreamOptions];</div><div class="line">    </div><div class="line">    if (!_scheduledRunloops.count) &#123;</div><div class="line">        [self scheduleInRunLoop:[NSRunLoop SR_networkRunLoop] forMode:NSDefaultRunLoopMode];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    [_outputStream open];</div><div class="line">    [_inputStream open];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这段代码才开始进行真正的连接。</p>
<p>下面这段是Apple文档对NSStreamDelegate的描述。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@protocol NSStreamDelegate &lt;NSObject&gt;</div><div class="line">@optional</div><div class="line">- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode;</div><div class="line">@end</div></pre></td></tr></table></figure>
<blockquote>
<p>The delegate receives this message when a given event has occurred on a given stream.<br>The delegate receives this message only if theStream is scheduled on a run loop. The message is sent on the stream object’s thread. The delegate should examine streamEvent to determine the appropriate action it should take.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode;</div><div class="line">&#123;</div><div class="line">	...</div><div class="line">    [weakSelf safeHandleEvent:eventCode stream:aStream];</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)safeHandleEvent:(NSStreamEvent)eventCode stream:(NSStream *)aStream</div><div class="line">&#123;</div><div class="line">        switch (eventCode) &#123;</div><div class="line">            case NSStreamEventOpenCompleted: &#123;</div><div class="line">	            ...</div><div class="line">	            ...</div><div class="line">	            [self didConnect];</div><div class="line">	            ...</div><div class="line">                [self _pumpWriting];</div><div class="line">                [self _pumpScanner];</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">                </div><div class="line">            case NSStreamEventErrorOccurred: &#123;</div><div class="line">	            ...</div><div class="line">	            ...</div><div class="line">                break;                </div><div class="line">            &#125;</div><div class="line">                </div><div class="line">            case NSStreamEventEndEncountered: &#123;</div><div class="line">                [self _pumpScanner];</div><div class="line">                ...</div><div class="line">                ...</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">                </div><div class="line">            case NSStreamEventHasBytesAvailable: &#123;</div><div class="line">                ...</div><div class="line">                ...</div><div class="line">                [self _pumpScanner];</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">                </div><div class="line">            case NSStreamEventHasSpaceAvailable: &#123;</div><div class="line">	            ...</div><div class="line">	            ...</div><div class="line">                [self _pumpWriting];</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">                </div><div class="line">            default:</div><div class="line">                SRFastLog(@&quot;(default)  %@&quot;, aStream);</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">- (void)didConnect;</div><div class="line">&#123;</div><div class="line">    SRFastLog(@&quot;Connected&quot;);</div><div class="line">    CFHTTPMessageRef request = CFHTTPMessageCreateRequest(NULL, CFSTR(&quot;GET&quot;), (__bridge CFURLRef)_url, kCFHTTPVersion1_1);</div><div class="line">    </div><div class="line">    // Set host first so it defaults</div><div class="line">    CFHTTPMessageSetHeaderFieldValue(request, CFSTR(&quot;Host&quot;), (__bridge CFStringRef)(_url.port ? [NSString stringWithFormat:@&quot;%@:%@&quot;, _url.host, _url.port] : _url.host));</div><div class="line">        </div><div class="line">    NSMutableData *keyBytes = [[NSMutableData alloc] initWithLength:16];</div><div class="line">    SecRandomCopyBytes(kSecRandomDefault, keyBytes.length, keyBytes.mutableBytes);</div><div class="line">    </div><div class="line">    if ([keyBytes respondsToSelector:@selector(base64EncodedStringWithOptions:)]) &#123;</div><div class="line">        _secKey = [keyBytes base64EncodedStringWithOptions:0];</div><div class="line">    &#125; else &#123;</div><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored &quot;-Wdeprecated-declarations&quot;</div><div class="line">        _secKey = [keyBytes base64Encoding];</div><div class="line">#pragma clang diagnostic pop</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    assert([_secKey length] == 24);</div><div class="line"></div><div class="line">    // Apply cookies if any have been provided</div><div class="line">    NSDictionary * cookies = [NSHTTPCookie requestHeaderFieldsWithCookies:[self requestCookies]];</div><div class="line">    for (NSString * cookieKey in cookies) &#123;</div><div class="line">        NSString * cookieValue = [cookies objectForKey:cookieKey];</div><div class="line">        if ([cookieKey length] &amp;&amp; [cookieValue length]) &#123;</div><div class="line">            CFHTTPMessageSetHeaderFieldValue(request, (__bridge CFStringRef)cookieKey, (__bridge CFStringRef)cookieValue);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    // set header for http basic auth</div><div class="line">    if (_url.user.length &amp;&amp; _url.password.length) &#123;</div><div class="line">        NSData *userAndPassword = [[NSString stringWithFormat:@&quot;%@:%@&quot;, _url.user, _url.password] dataUsingEncoding:NSUTF8StringEncoding];</div><div class="line">        NSString *userAndPasswordBase64Encoded;</div><div class="line">        if ([keyBytes respondsToSelector:@selector(base64EncodedStringWithOptions:)]) &#123;</div><div class="line">            userAndPasswordBase64Encoded = [userAndPassword base64EncodedStringWithOptions:0];</div><div class="line">        &#125; else &#123;</div><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored &quot;-Wdeprecated-declarations&quot;</div><div class="line">            userAndPasswordBase64Encoded = [userAndPassword base64Encoding];</div><div class="line">#pragma clang diagnostic pop</div><div class="line">        &#125;</div><div class="line">        _basicAuthorizationString = [NSString stringWithFormat:@&quot;Basic %@&quot;, userAndPasswordBase64Encoded];</div><div class="line">        CFHTTPMessageSetHeaderFieldValue(request, CFSTR(&quot;Authorization&quot;), (__bridge CFStringRef)_basicAuthorizationString);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    CFHTTPMessageSetHeaderFieldValue(request, CFSTR(&quot;Upgrade&quot;), CFSTR(&quot;websocket&quot;));</div><div class="line">    CFHTTPMessageSetHeaderFieldValue(request, CFSTR(&quot;Connection&quot;), CFSTR(&quot;Upgrade&quot;));</div><div class="line">    CFHTTPMessageSetHeaderFieldValue(request, CFSTR(&quot;Sec-WebSocket-Key&quot;), (__bridge CFStringRef)_secKey);</div><div class="line">    CFHTTPMessageSetHeaderFieldValue(request, CFSTR(&quot;Sec-WebSocket-Version&quot;), (__bridge CFStringRef)[NSString stringWithFormat:@&quot;%ld&quot;, (long)_webSocketVersion]);</div><div class="line">    </div><div class="line">    CFHTTPMessageSetHeaderFieldValue(request, CFSTR(&quot;Origin&quot;), (__bridge CFStringRef)_url.SR_origin);</div><div class="line">    </div><div class="line">    if (_requestedProtocols) &#123;</div><div class="line">        CFHTTPMessageSetHeaderFieldValue(request, CFSTR(&quot;Sec-WebSocket-Protocol&quot;), (__bridge CFStringRef)[_requestedProtocols componentsJoinedByString:@&quot;, &quot;]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    [_urlRequest.allHTTPHeaderFields enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123;</div><div class="line">        CFHTTPMessageSetHeaderFieldValue(request, (__bridge CFStringRef)key, (__bridge CFStringRef)obj);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    NSData *message = CFBridgingRelease(CFHTTPMessageCopySerializedMessage(request));</div><div class="line">    </div><div class="line">    CFRelease(request);</div><div class="line"></div><div class="line">    [self _writeData:message];//socket连接成功，发送客户端websocket握手请求</div><div class="line">    [self _readHTTPHeader];//等待并开始读取服务器websocket握手响应</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (void)_readHTTPHeader;</div><div class="line">&#123;</div><div class="line">    if (_receivedHTTPHeaders == NULL) &#123;</div><div class="line">        _receivedHTTPHeaders = CFHTTPMessageCreateEmpty(NULL, NO);</div><div class="line">    &#125;</div><div class="line">                        </div><div class="line">    [self _readUntilHeaderCompleteWithCallback:^(SRWebSocket *self,  NSData *data) &#123;</div><div class="line">        CFHTTPMessageAppendBytes(_receivedHTTPHeaders, (const UInt8 *)data.bytes, data.length);</div><div class="line">        </div><div class="line">        if (CFHTTPMessageIsHeaderComplete(_receivedHTTPHeaders)) &#123;</div><div class="line">            SRFastLog(@&quot;Finished reading headers %@&quot;, CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(_receivedHTTPHeaders)));</div><div class="line">            [self _HTTPHeadersDidFinish];</div><div class="line">        &#125; else &#123;</div><div class="line">            [self _readHTTPHeader];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我本地debug收到服务器返回的response header数据如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 101 Switching Protocols</div><div class="line">Server: Tengine/2.1.2</div><div class="line">Date: Thu, 15 Dec 2016 08:32:40 GMT</div><div class="line">Connection: upgrade</div><div class="line">Upgrade: websocket</div><div class="line">Sec-WebSocket-Accept: 0EDYPFTXV+u3rkKflAelaATKEvA=</div><div class="line">&lt;space-space-space-space-space-space-space-space-space-space</div></pre></td></tr></table></figure>
<p>最后一行是一个空白行,所以判断是http header是否结束的标志就是”\r\n\r\n”，请查看源码1262行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (void)_HTTPHeadersDidFinish;</div><div class="line">&#123;</div><div class="line">    NSInteger responseCode = CFHTTPMessageGetResponseStatusCode(_receivedHTTPHeaders);    </div><div class="line">    if (responseCode &gt;= 400) &#123;</div><div class="line">	    ...</div><div class="line">	    ...</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">	...    </div><div class="line">    self.readyState = SR_OPEN;    </div><div class="line">    if (!_didFail) &#123;</div><div class="line">        [self _readFrameNew];//websocket协商完毕，开始读取正式数据。</div><div class="line">    &#125;</div><div class="line">    [self _performDelegateBlock:^&#123;</div><div class="line">        if ([self.delegate respondsToSelector:@selector(webSocketDidOpen:)]) &#123;</div><div class="line">            [self.delegate webSocketDidOpen:self];</div><div class="line">        &#125;;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>截止到这里，websocket协商完毕，开始读取正式数据。当时代码看到这里的时候我也消除了一个内心的疑惑，为什么对面Android同事在websocket连接过程中http抓包软件可以抓到，而我用SocketRocket则完全抓不到？原因就是：我们iOS手机与服务器之间已经建立了一条长连接，然后自己组装websocket的http header发送出去的。所以普通的http抓包软件只能抓空气，想要抓我们的包，得Wireshark等这种更屌的抓包工具才行。（深深的鄙视了一眼对面的Androider）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (void)_readFrameNew;</div><div class="line">&#123;</div><div class="line">    dispatch_async(_workQueue, ^&#123;</div><div class="line">        [_currentFrameData setLength:0];        </div><div class="line">        _currentFrameOpcode = 0;</div><div class="line">        _currentFrameCount = 0;</div><div class="line">        _readOpCount = 0;</div><div class="line">        _currentStringScanPosition = 0;        </div><div class="line">        [self _readFrameContinue];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line">- (void)_readFrameContinue;</div><div class="line">&#123;</div><div class="line">    assert((_currentFrameCount == 0 &amp;&amp; _currentFrameOpcode == 0) || (_currentFrameCount &gt; 0 &amp;&amp; _currentFrameOpcode &gt; 0));</div><div class="line"></div><div class="line">    [self _addConsumerWithDataLength:2 callback:^(SRWebSocket *self, NSData *data) &#123;</div><div class="line">        __block frame_header header = &#123;0&#125;;</div><div class="line">        </div><div class="line">        const uint8_t *headerBuffer = data.bytes;</div><div class="line">        assert(data.length &gt;= 2);</div><div class="line">        </div><div class="line">        if (headerBuffer[0] &amp; SRRsvMask) &#123;</div><div class="line">            [self _closeWithProtocolError:@&quot;Server used RSV bits&quot;];</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        uint8_t receivedOpcode = (SROpCodeMask &amp; headerBuffer[0]);</div><div class="line">        </div><div class="line">        BOOL isControlFrame = (receivedOpcode == SROpCodePing || receivedOpcode == SROpCodePong || receivedOpcode == SROpCodeConnectionClose);</div><div class="line">        </div><div class="line">        if (!isControlFrame &amp;&amp; receivedOpcode != 0 &amp;&amp; self-&gt;_currentFrameCount &gt; 0) &#123;</div><div class="line">            [self _closeWithProtocolError:@&quot;all data frames after the initial data frame must have opcode 0&quot;];</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        if (receivedOpcode == 0 &amp;&amp; self-&gt;_currentFrameCount == 0) &#123;</div><div class="line">            [self _closeWithProtocolError:@&quot;cannot continue a message&quot;];</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        header.opcode = receivedOpcode == 0 ? self-&gt;_currentFrameOpcode : receivedOpcode;</div><div class="line">        </div><div class="line">        header.fin = !!(SRFinMask &amp; headerBuffer[0]);</div><div class="line">        </div><div class="line">        </div><div class="line">        header.masked = !!(SRMaskMask &amp; headerBuffer[1]);</div><div class="line">        header.payload_length = SRPayloadLenMask &amp; headerBuffer[1];</div><div class="line">        </div><div class="line">        headerBuffer = NULL;</div><div class="line">        </div><div class="line">        if (header.masked) &#123;</div><div class="line">            [self _closeWithProtocolError:@&quot;Client must receive unmasked data&quot;];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        size_t extra_bytes_needed = header.masked ? sizeof(_currentReadMaskKey) : 0;</div><div class="line">        </div><div class="line">        if (header.payload_length == 126) &#123;</div><div class="line">            extra_bytes_needed += sizeof(uint16_t);</div><div class="line">        &#125; else if (header.payload_length == 127) &#123;</div><div class="line">            extra_bytes_needed += sizeof(uint64_t);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        if (extra_bytes_needed == 0) &#123;</div><div class="line">            [self _handleFrameHeader:header curData:self-&gt;_currentFrameData];</div><div class="line">        &#125; else &#123;</div><div class="line">            [self _addConsumerWithDataLength:extra_bytes_needed callback:^(SRWebSocket *self, NSData *data) &#123;</div><div class="line">                size_t mapped_size = data.length;</div><div class="line">                #pragma unused (mapped_size)</div><div class="line">                const void *mapped_buffer = data.bytes;</div><div class="line">                size_t offset = 0;</div><div class="line">                </div><div class="line">                if (header.payload_length == 126) &#123;</div><div class="line">                    assert(mapped_size &gt;= sizeof(uint16_t));</div><div class="line">                    uint16_t newLen = EndianU16_BtoN(*(uint16_t *)(mapped_buffer));</div><div class="line">                    header.payload_length = newLen;</div><div class="line">                    offset += sizeof(uint16_t);</div><div class="line">                &#125; else if (header.payload_length == 127) &#123;</div><div class="line">                    assert(mapped_size &gt;= sizeof(uint64_t));</div><div class="line">                    header.payload_length = EndianU64_BtoN(*(uint64_t *)(mapped_buffer));</div><div class="line">                    offset += sizeof(uint64_t);</div><div class="line">                &#125; else &#123;</div><div class="line">                    assert(header.payload_length &lt; 126 &amp;&amp; header.payload_length &gt;= 0);</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                if (header.masked) &#123;</div><div class="line">                    assert(mapped_size &gt;= sizeof(_currentReadMaskOffset) + offset);</div><div class="line">                    memcpy(self-&gt;_currentReadMaskKey, ((uint8_t *)mapped_buffer) + offset, sizeof(self-&gt;_currentReadMaskKey));</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                [self _handleFrameHeader:header curData:self-&gt;_currentFrameData];</div><div class="line">            &#125; readToCurrentFrame:NO unmaskBytes:NO];</div><div class="line">        &#125;</div><div class="line">    &#125; readToCurrentFrame:NO unmaskBytes:NO];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>SocketRocket有两个“泵”方法：_pumpWriting、_pumpScanner，这两个“泵”保证了websocket数据的发送、接受功能。这两个“泵”的代码写的很不错哦，很巧妙的解决了socket数据的接收解析和发送，挺有参考意义的，毕竟人家是Facebook的。</p>
<hr>
<p>有空再继续，里面还是有很多小细节的，这些小细节的处理方法也是值得我们学习的。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/12/18/iOS-Blocks的实现原理/" class="prev">PREV</a><a href="/2016/11/30/iOS判断当前输入法是系统自带还是第三方/" class="next">NEXT</a></div><div data-thread-key="2016/12/14/WebSocket协议-SocketRocket源码学习/" data-title="WebSocket协议、SocketRocket源码学习" data-url="http://antyme.com/2016/12/14/WebSocket协议-SocketRocket源码学习/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"antyme"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2012 - 2016 <a href="http://antyme.com">bug小英雄</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>