<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bug world</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://antyme.com/"/>
  <updated>2016-12-14T10:42:02.000Z</updated>
  <id>http://antyme.com/</id>
  
  <author>
    <name>bug小英雄</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WebSocket协议-SocketRocket源码学习</title>
    <link href="http://antyme.com/2016/12/14/WebSocket%E5%8D%8F%E8%AE%AE-SocketRocket%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://antyme.com/2016/12/14/WebSocket协议-SocketRocket源码学习/</id>
    <published>2016-12-14T08:36:44.000Z</published>
    <updated>2016-12-14T10:42:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://tools.ietf.org/html/rfc6455#section-5.5.1" target="_blank" rel="external">rfc6455 WebSockets 标准</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/WebSockets/Writing_WebSocket_servers" target="_blank" rel="external">编写 WebSocket 服务器</a></p>
<h3 id="WebSocket概述、握手"><a href="#WebSocket概述、握手" class="headerlink" title="WebSocket概述、握手"></a>WebSocket概述、握手</h3><p>首先，服务器必须通过标准 TCP 套接字来侦听外来的连接请求。取决于你的平台，可能已经处理好握手了。举个例子，我们假定你的服务监听在地址 example.com ，端口号 8000 上，而且能够回应路径 /chat 上的 GET 请求。</p>
<blockquote>
<p>警告: 服务器监听任意所选择的端口，但是如果在 80 或者 443 之外的端口上，可能会在防火墙或者代理上出问题。在 443 端口上比较容易成功，但是需要安全连接（TLS/SSL）。另外就是大多数浏览器（比如 Firefox 8+）不允许在安全页面上连接不安全的 WebSocket 服务器。</p>
</blockquote>
<p>握手这一环节就是 WebSockets 上的“web”。它是从 HTTP 到 WS 的桥梁。握手时会协商连接的详细信息，并且如果条件不适合，任何一方都可以在成功建立连接之前退出。服务器一定要清楚客户端所要求的一切信息，否则可能会发生安全问题。</p>
<h5 id="客户端握手请求"><a href="#客户端握手请求" class="headerlink" title="客户端握手请求"></a>客户端握手请求</h5><p>即使你正在构建一个服务，WebSocket 握手请求仍需要由客户端发起。因此你必须知道如何解读客户端信息。首先客户端会发送类似这样的标准 HTTP 请求（HTTP 版本号最低为 1.1 ，而且请求方法必须为 GET）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">GET /chat HTTP/1.1</div><div class="line">Host: example.com:8000</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</div><div class="line">Sec-WebSocket-Version: 13</div></pre></td></tr></table></figure>
<p>客户端可以请求扩展和/或子协议化，详见<a href="https://developer.mozilla.org/zh-CN/docs/WebSockets/Writing_WebSocket_servers#Miscellaneous" target="_blank" rel="external">杂项</a>。另外，常规的头部信息如User-Agent,Referer, Cookie, or authentication 等也可能会出现。你可以随意处理这些内容，它们并不直接属于WebScoket的一部分，忽略它们也没事。在许多的常见设置中，反向代理已经对它们进行了处理。</p>
<p>如果存在任何未知或者错误的请求头，服务器应该发送一个 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#400" target="_blank" rel="external">“400 Bad Request”</a>并立即关闭 socket。像往常一样，也可以在HTTP响应体中给出握手失败的原因，但是这个消息可能从来都不会显示出来 (浏览器不显示)。 如果服务器无法理解请求的WebSockets的版本，它应该发送一个包含它能理解的版本号的Sec-WebSocket-Version的头部信息。 (本指南解释了最新版本的v13)。现在让我们来了解一下最让人期待的头部信息，Sec-WebSocket-Key。</p>
<blockquote>
<p><em>提示: 所有的浏览器都会发送 Origin 请求头，你可以用它来处理安全问题（比如黑名单，白名单，origin检查之类的）然后发送回去 403 Forbidden 来禁止连接。但是要注意，非浏览器客户端可以发送伪造的 Origin。大多数应用如果没有检测到 Origin 请求头将会拒绝请求。</em></p>
<p><em>提示: 请求地址 (例如这里是 /chat ) 在规范中没有明确定义。所以许多人巧妙的利用这点，让一个服务器处理多个 WebSocket 应用。例如在 example.com/chat 上是一个聊天室，与此同时在 /game 上运行一个多人联机游戏。</em></p>
<p><em>注意: 常规 HTTP 状态码 只能在握手前使用。握手成功后，你就得用不同的代码了 (参阅规范的第7章第4节 ).</em></p>
</blockquote>
<h5 id="服务器握手响应"><a href="#服务器握手响应" class="headerlink" title="服务器握手响应"></a>服务器握手响应</h5><p>服务器收到握手请求后，就应该发送一个看起来很怪异 (但是仍然是 HTTP ) 的响应，就像这样：(记得每一个响应头之间用 \r\n 间隔，最后再放一个 \r\n 空行)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 101 Switching Protocols</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</div></pre></td></tr></table></figure>
<p>此外，服务器在这里也可以指明 扩展/子协议，具体参考 杂项。其中的 Sec-WebSocket-Accept 比较有意思。要生成它，将客户端提供的 Sec-WebSocket-Key 和规定中指明的 魔法字符串 “258EAFA5-E914-47DA-95CA-C5AB0DC85B11” 简单地连在一起，进行 SHA-1 Hash，然后用 base64 编码，返回结果即可。</p>
<blockquote>
<p>仅供参考: 这个过程对于判断服务器是否支持WebSockets这个很明显的事情来说可能显得太过复杂。但是，这非常重要，如果服务器接受了一个WebSockets的链接却按照HTTP请求来解析可能会带来安全上的问题。</p>
</blockquote>
<p>所以假设客户端发来的是 “dGhlIHNhbXBsZSBub25jZQ==”，服务器就回复 “s3pPLMBiTxaQ9kYGzzhZRbK+xOo=”。一旦服务器发送完这些响应头，连接就建立了，可以开始交换数据了。</p>
<blockquote>
<p>当然服务器也可以发送 Set-Cookie 之类的头，或者关于认证的请求，或者通过其他状态码重定向，总之只要在握手响应信息发出之前都可以。</p>
</blockquote>
<h5 id="持续追踪客户端"><a href="#持续追踪客户端" class="headerlink" title="持续追踪客户端"></a>持续追踪客户端</h5><p>这部分和Websocket协议没有直接关系，但请务必注意：你的服务器必须持续追踪每个客户端的socket以避免进行重复的握手。同一个客户IP地址可能尝试连接多次（但服务器为保护自己免受DoS拒绝服务式攻击，也可拒绝那些过多请求连接的客户端）。</p>
<h3 id="WebSocket协议"><a href="#WebSocket协议" class="headerlink" title="WebSocket协议"></a>WebSocket协议</h3><blockquote>
<p>我们知道客户端和服务端都能在任意时候发送数据——这是WebSocket的神奇之处，而且不管数据是从客户端-&gt;服务端，还是从服务端-&gt;客户端，每个数据帧（包）的格式都是一样的，如下表所示：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">0                   1                   2                   3</div><div class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</div><div class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</div><div class="line">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</div><div class="line">|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</div><div class="line">|N|V|V|V|       |S|             |   (if payload len==126/127)   |</div><div class="line">| |1|2|3|       |K|             |                               |</div><div class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</div><div class="line">|     Extended payload length continued, if payload len == 127  |</div><div class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</div><div class="line">|                               |Masking-key, if MASK set to 1  |</div><div class="line">+-------------------------------+-------------------------------+</div><div class="line">| Masking-key (continued)       |          Payload Data         |</div><div class="line">+-------------------------------- - - - - - - - - - - - - - - - +</div><div class="line">:                     Payload Data continued ...                :</div><div class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</div><div class="line">|                     Payload Data continued ...                |</div><div class="line">+---------------------------------------------------------------+</div><div class="line"></div><div class="line">							websocket协议（数据帧格式）</div></pre></td></tr></table></figure>
<blockquote>
<p>1、字段FIN：FIN 位和操作码字段共同起到把一个报文分成几个数据帧发送的作用。这就叫做报文分段，分段只在操作码为 0x0、0x1、0x2 时有效。下面demo-1详细介绍其用法。</p>
<p>2、字段RSV1、RSV2、RSV3可忽略，那是用于扩展的保留字段。</p>
<p>3、字段opcode：操作码(opcode) 字段定义怎样解释负载数据： 字段定义了如何解释有效负载数据:  0x0 为继续，0x1 文本 (以 utf-8 编码)，0x2 为二进制数据，和后面将要讨论的其他所谓”控制代码”。在此版本的 Websocket（当前版本号为13），0x3 到 0x7 和 0xB 到 0xF 无意义。<br><br></p>
<ul>
<li>0x00：表示这帧是连续的帧，应该把这帧的负载数据连接到接收的上一帧，下面demo1描述了具体的用法。<br><br></li>
<li>0x01：负载数据是文本。<br><br></li>
<li>0x02：负载数据是二进制数据。<br><br></li>
<li>0x08：关闭连接的请求帧，要关闭一个连接的话，客户端或者服务端可以发送一个带有一段特殊控制序列数据的控制帧，来开始挥手过程。一旦接收到这样的帧，另一方发送关闭帧作为回应。任何关闭连接之后的数据将被废弃。（我在调试的时候这个值等于’\b’，知道为什么吗😝）<br><br></li>
<li>0x9：Ping包，在握手后的任何一个时间点，客户端或者服务器可以选择发送一个ping包给对方。<br> <br></li>
<li>0xA：Pong包，当ping包被收到时，接受者必须尽可能快的发回pong包。例如，你可以使用这个机制来确定客户端仍然处于连接状态。</li>
</ul>
<p>4、字段MASK：MASK字段表明报文是否被编码（按：即前述XOR异或加密）。客户端发来的消息应该被掩蔽，所以你的服务器应该期待这个位为1。（事实上，<a href="https://tools.ietf.org/html/rfc6455#section-5.1节" target="_blank" rel="external">rfc6455 websocket规范的5.1</a>说如客户端发来“未掩蔽”的报文那服务端应该断开这个连接。）服务端回报文给客户端则不要掩蔽数据，相应的MASK位为0。稍后我们将解释掩蔽。注意：即使在一个安全套接字上传输数据，也要遵守上述规则。</p>
<p>5、字段Payload len（9-15位）：读取负载数据，需要知道读到那里为止。因此获知负载数据长度很重要。这个过程稍微有点复杂，要以下这些步骤：</p>
<ul>
<li>读取9-15位 (包括9和15位本身)，并转换为无符号整数。如果值小于或等于125，这个值就是长度；如果是 126，请转到步骤 2。如果它是 127，请转到步骤 3。</li>
<li>读取接下来的 16 位并转换为无符号整数，并作为长度。</li>
<li>读取接下来的 64 位并转换为无符号整数 (最高有效位必须为0)，并作为长度。</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Client: FIN=1, opcode=0x1, msg=&quot;hello&quot;</div><div class="line">Server: (process complete message immediately) Hi.</div><div class="line">Client: FIN=0, opcode=0x1, msg=&quot;and a&quot;</div><div class="line">Server: (listening, new message containing text started)</div><div class="line">Client: FIN=0, opcode=0x0, msg=&quot;happy new&quot;</div><div class="line">Server: (listening, payload concatenated to previous message)</div><div class="line">Client: FIN=1, opcode=0x0, msg=&quot;year!&quot;</div><div class="line">Server: (process complete message) Happy new year to you too!</div><div class="line"></div><div class="line">								demo-1</div></pre></td></tr></table></figure>
<p>demo-1描述服务器如何回应客户端发送的文本数据。第一个报文发送了单个数据帧，而第二个报文通过三帧发送。 只展示的客户端的 FIN 位和操作码。</p>
<h3 id="WebSocket-iOS开源库源码学习（facebook）"><a href="#WebSocket-iOS开源库源码学习（facebook）" class="headerlink" title="WebSocket iOS开源库源码学习（facebook）"></a>WebSocket iOS开源库源码学习（<a href="https://github.com/facebook/SocketRocket" target="_blank" rel="external">facebook</a>）</h3><pre><code>正在组织语言中...敬请期待
</code></pre><hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6455#section-5.5.1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;rfc6455 WebSockets 标准&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http
    
    </summary>
    
    
      <category term="iOS/WebSocket/SocketRocket源码" scheme="http://antyme.com/tags/iOS-WebSocket-SocketRocket%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>iOS判断当前输入法是系统自带还是第三方</title>
    <link href="http://antyme.com/2016/11/30/iOS%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E8%BE%93%E5%85%A5%E6%B3%95%E6%98%AF%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%B8%A6%E8%BF%98%E6%98%AF%E7%AC%AC%E4%B8%89%E6%96%B9/"/>
    <id>http://antyme.com/2016/11/30/iOS判断当前输入法是系统自带还是第三方/</id>
    <published>2016-11-30T03:30:07.000Z</published>
    <updated>2016-11-30T03:49:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://stackoverflow.com/questions/26153336/how-do-i-find-out-the-current-keyboard-used-on-ios8" target="_blank" rel="external">参考链接</a></p>
<p>目前iOS SDK还没有公开获取当前键盘的name，但国外大神找到了“灰色”方法可以获取到，前提是键盘处于visible活跃状态。（现在还不确定能否通过审核😅）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSString *currentKeyboardName = [[[[UITextInputMode activeInputModes] filteredArrayUsingPredicate:[NSPredicate predicateWithFormat:@&quot;isDisplayed = YES&quot;]] lastObject] valueForKey:@&quot;extendedDisplayName&quot;];</div><div class="line">if ([currentKeyboardName isEqualToString:@&quot;简体拼音&quot;] || [currentKeyboardName isEqualToString:@&quot;表情符号&quot;] || [currentKeyboardName isEqualToString:@&quot;English (US)&quot;]) &#123;</div><div class="line">//系统自带键盘</div><div class="line">&#125; else &#123;</div><div class="line">//第三方键盘 eg:百度、搜狗、讯飞等</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/26153336/how-do-i-find-out-the-current-keyboard-used-on-ios8&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://antyme.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL学习与理解</title>
    <link href="http://antyme.com/2016/09/25/OpenGL%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%90%86%E8%A7%A3/"/>
    <id>http://antyme.com/2016/09/25/OpenGL学习与理解/</id>
    <published>2016-09-25T07:41:11.000Z</published>
    <updated>2016-09-25T08:34:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素。3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线（Graphics Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。</p>
<p><img src="/images/pipeline.png" alt=""></p>
<p>首先，我们以数组的形式传递3个3D坐标作为图形渲染管线的输入，用来表示一个三角形，这个数组叫做顶点数据(Vertex Data)；顶点数据是一系列顶点的集合。一个顶点(Vertex)是一个3D坐标的数据的集合。而顶点数据是用顶点属性(Vertex Attribute)表示的，它可以包含任何我们想用的数据，但是简单起见，我们还是假定每个顶点只由一个3D位置(译注1)和一些颜色值组成的吧。</p>
<p>图形渲染管线的第一个部分是顶点着色器(Vertex Shader)，它把一个单独的顶点作为输入。顶点着色器主要的目的是把3D坐标转为另一种3D坐标（后面会解释），同时顶点着色器允许我们对顶点属性进行一些基本处理。</p>
<p>图元装配(Primitive Assembly)阶段将顶点着色器输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并所有的点装配成指定图元的形状；本节例子中是一个三角形。</p>
<p>图元装配阶段的输出会传递给几何着色器(Geometry Shader)。几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状。例子中，它生成了另一个三角形。</p>
<p>几何着色器的输出会被传入光栅化阶段(Rasterization Stage)，这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。</p>
<blockquote>
<p>OpenGL中的一个片段是OpenGL渲染一个像素所需的所有数据。</p>
</blockquote>
<p>片段着色器的主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素。3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线（Graphics Pipeline，大多译为管线，实际上指的是一
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS开发中方便好用的C语言宏</title>
    <link href="http://antyme.com/2016/08/18/C%E8%AF%AD%E8%A8%80%E5%AE%8F%E7%9A%84%E7%89%B9%E6%AE%8A%E7%94%A8%E6%B3%95%E5%92%8C%E5%87%A0%E4%B8%AA%E5%9D%91/"/>
    <id>http://antyme.com/2016/08/18/C语言宏的特殊用法和几个坑/</id>
    <published>2016-08-18T10:51:22.000Z</published>
    <updated>2016-12-08T08:08:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="宏特殊用法"><a href="#宏特殊用法" class="headerlink" title="宏特殊用法"></a>宏特殊用法</h2><h3 id="1-字符串化-Stringification"><a href="#1-字符串化-Stringification" class="headerlink" title="1. 字符串化(Stringification)"></a>1. 字符串化(Stringification)</h3><p>在宏体中，如果宏参数前加个<strong>#</strong>，那么在宏体扩展的时候，宏参数会被扩展成字符串的形式。如：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> WARN_IF(EXP) \</span></div><div class="line">do &#123; <span class="meta-keyword">if</span> (EXP) \</div><div class="line">	fprintf (stderr, <span class="meta-string">"Warning: "</span> #EXP <span class="meta-string">"\n"</span>); &#125; \</div><div class="line">while (0)</div></pre></td></tr></table></figure>
<p><strong>WARN_IF (x == 0);</strong>会被扩展成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">do </div><div class="line">&#123; </div><div class="line">	if (x == 0)</div><div class="line">		fprintf (stderr, &quot;Warning: &quot; &quot;x == 0&quot; &quot;\n&quot;); </div><div class="line">&#125;</div><div class="line">while (0);</div></pre></td></tr></table></figure>
<p>这种用法可以用在assert中，如果断言失败，可以将失败的语句输出到反馈信息中</p>
<h3 id="2-连接-Concatenation"><a href="#2-连接-Concatenation" class="headerlink" title="2. 连接(Concatenation)"></a>2. 连接(Concatenation)</h3><p>在宏体中，如果宏体所在标示符中有<strong>##</strong>，那么在宏体扩展的时候，宏参数会被直接替换到标示符中。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#define COMMAND(NAME)  &#123; #NAME, NAME ## _command &#125;</div><div class="line">struct command</div><div class="line">&#123;</div><div class="line">    char *name;</div><div class="line">    void (*function) (void);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在宏扩展的时候：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct command commands[] =</div><div class="line">&#123;</div><div class="line">    COMMAND (quit),</div><div class="line">    COMMAND (help),</div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>会被扩展成：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct command commands[] =</div><div class="line">&#123;</div><div class="line">    &#123; &quot;quit&quot;, quit_command &#125;,</div><div class="line">    &#123; &quot;help&quot;, help_command &#125;,</div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这样就节省了大量时间，提高效率。</p>
<h3 id="3-iOS中定义明确类型的模板容器"><a href="#3-iOS中定义明确类型的模板容器" class="headerlink" title="3. iOS中定义明确类型的模板容器"></a>3. iOS中定义明确类型的模板容器</h3><p>定义NSArray、NSMutableArray、NSDictionary、NSMutableDictionary等泛型容器时最好指定类型，这样不但可以充分利用Xcode的自动完成功能，提升效率，而且便于代码的维护。<br>下面的宏可以帮你快速实现这一点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#if __has_feature(objc_generics)</div><div class="line">#   define TM__GENERICS(class, ...)         class&lt;__VA_ARGS__&gt;</div><div class="line">#else</div><div class="line">#   define TM__GENERICS(class, ...)         class</div><div class="line">#endif</div><div class="line"></div><div class="line">#define TMMutableArrayWith(valueType)                   TM__GENERICS(NSMutableArray, valueType)</div><div class="line">#define TMMutableDictionaryWith(keyType, valueType)     TM__GENERICS(NSMutableDictionary, keyType, valueType)</div></pre></td></tr></table></figure>
<h3 id="未完待补充…"><a href="#未完待补充…" class="headerlink" title="未完待补充…"></a>未完待补充…</h3><hr>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;宏特殊用法&quot;&gt;&lt;a href=&quot;#宏特殊用法&quot; class=&quot;headerlink&quot; title=&quot;宏特殊用法&quot;&gt;&lt;/a&gt;宏特殊用法&lt;/h2&gt;&lt;h3 id=&quot;1-字符串化-Stringification&quot;&gt;&lt;a href=&quot;#1-字符串化-Stringificat
    
    </summary>
    
    
      <category term="c/c++" scheme="http://antyme.com/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>git好用容易忘记的命令</title>
    <link href="http://antyme.com/2016/08/18/git%E5%A5%BD%E7%94%A8%E5%AE%B9%E6%98%93%E5%BF%98%E8%AE%B0%E7%9A%84%E5%91%BD%E4%BB%A4/"/>
    <id>http://antyme.com/2016/08/18/git好用容易忘记的命令/</id>
    <published>2016-08-18T10:30:48.000Z</published>
    <updated>2016-08-18T10:33:13.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="git好用容易忘记的命令"><a href="#git好用容易忘记的命令" class="headerlink" title="git好用容易忘记的命令"></a><strong>git好用容易忘记的命令</strong></h3><p>1、移除文件</p>
<pre><code>删除本地和git跟踪：
    git rm
只删除git跟踪，保留本地：
    git rm --cached 文件名
</code></pre><p>2、移动文件</p>
<pre><code>git mv srcName dstName
相当于
mv srcName dstName
git rm srcName
git add dstName
</code></pre><p>3、查看日志</p>
<pre><code>git log
仅展示简要的增改行数统计
git log --stat
使用pretty选项适合自己风格的格式
git log --pretty=oneline
git log --pretty=short
git log --pretty=full
git log --pretty=fuller
git log --pretty=format:&quot;%h - %an, %ar : %s&quot;

format参数说明：
%H 提交对象（commit）的完整哈希字符串
%h    提交对象的简短哈希字符串
%T    树对象（tree）的完整哈希字符串
%t    树对象的简短哈希字符串
%P    父对象（parent）的完整哈希字符串
%p    父对象的简短哈希字符串
%an    作者（author）的名字
%ae    作者的电子邮件地址
%ad    作者修订日期（可以用 -date= 选项定制格式）
%ar    作者修订日期，按多久以前的方式显示
%cn    提交者（committer）的名字
%ce    提交者的电子邮箱地址
%cd    提交日期
%cr    提交日期，按多久以前的方式显示
%s    提交说明

git log常用命令选项：
-p                按补丁格式显示每个更新之间的差异
--stat            显示每次更新的文件修改统计信息
--shortstat        只显示--stat中最后的行数修改添加移除统计
--name-only        仅在提交信息后显示已修改的文件清单
--name-status    显示新增、修改、删除的文件清单
--abbrev-commit    仅显示SHA-1的前几个字符，而非所有的40个字符
--relative-date    使用较短的相对时间显示（比如，“2 week ago”）
--graph            显示ASCII图形表示的分支合并历史
--pretty        使用其他格式显示历史提交信息。可用的选项包括oneline、short、full、fuller和format（后跟指定格式）
-n                     仅显示最近的n条提交
--since, --after    仅显示指定时间之后的提交
--until, --before    仅显示指定时间之前的提交
--author            仅显示指定作者相关的提交
--committer            仅显示指定提交者相关的提交

git log --since=2.minutes
git log --since=2.weeks
git log --before=&quot;2016-08-17&quot;
git log --after=&quot;2016-08-16&quot; --before=&quot;2018-08-17&quot;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;git好用容易忘记的命令&quot;&gt;&lt;a href=&quot;#git好用容易忘记的命令&quot; class=&quot;headerlink&quot; title=&quot;git好用容易忘记的命令&quot;&gt;&lt;/a&gt;&lt;strong&gt;git好用容易忘记的命令&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;1、移除文件&lt;/p&gt;
&lt;p
    
    </summary>
    
    
      <category term="git" scheme="http://antyme.com/tags/git/"/>
    
  </entry>
  
</feed>
