<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bug world</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://antyme.com/"/>
  <updated>2018-05-09T05:46:32.932Z</updated>
  <id>http://antyme.com/</id>
  
  <author>
    <name>bug小英雄</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>android编译libwebp源码</title>
    <link href="http://antyme.com/2018/05/08/android%E7%BC%96%E8%AF%91libwebp%E6%BA%90%E7%A0%81/"/>
    <id>http://antyme.com/2018/05/08/android编译libwebp源码/</id>
    <published>2018-05-08T02:47:55.000Z</published>
    <updated>2018-05-09T05:46:32.932Z</updated>
    
    <content type="html"><![CDATA[<p>现在的Android版本都支持Webp，如果要不是JNI层需要直接调用Encode、Decode等API，根本没必要自己编译。现在公司项目需要在c++层调用Encode生成Webp，所以就自己编译，方便后续的更新和管理。其实Webp源码里面对不同OS的构建编译支持的已经很完善了，例如iOS，直接执行shell就可以生成Framework，编译Android需要一点点额外工作需要做，记录下这几个步骤，方便后续健忘的自己或者其他有需要的人可以快速编译。</p>
<p>1、下载源码（git、http）<br>2、在源码根目录下新建 <code>Application.mk</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># --------------------------------------------------------------------------------------</div><div class="line"># Building Options</div><div class="line"># --------------------------------------------------------------------------------------</div><div class="line"># Application Config</div><div class="line">APP_BUILD_SCRIPT := Android.mk</div><div class="line">APP_STL := gnustl_static</div><div class="line">APP_CPPFLAGS := -D__ANDROID__ -frtti -fexceptions -std=c++11</div><div class="line">APP_ABI :=armeabi-v7a arm64-v8a</div><div class="line">#APP_ABI :=arm64-v8a</div><div class="line">#NDK_TOOLCHAIN_VERSION:=4.9</div><div class="line"></div><div class="line"># Do not to assign &apos;debug&apos; here, it may cause crash</div><div class="line">APP_OPTIM := release</div></pre></td></tr></table></figure>
<p>3、如果需要编译动态库，修改webp源码自带的Android.mk文件，在文件刚开始一点的地方定义变量：<code>ENABLE_SHARED :=1</code>，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">LOCAL_PATH := $(call my-dir)</div><div class="line"></div><div class="line">WEBP_CFLAGS := -Wall -DANDROID -DHAVE_MALLOC_H -DHAVE_PTHREAD -DWEBP_USE_THREAD</div><div class="line">WEBP_CFLAGS += -fvisibility=hidden</div><div class="line"></div><div class="line">ENABLE_SHARED :=1</div><div class="line">..................................................</div><div class="line">.........................</div><div class="line">.........................</div><div class="line">.........................</div></pre></td></tr></table></figure></p>
<p>4、命令行执行 <code>ndk-build NDK_PROJECT_PATH=. NDK_APPLICATION_MK=Application.mk</code> 即可生成需要的so文件和一些可执行文件。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在的Android版本都支持Webp，如果要不是JNI层需要直接调用Encode、Decode等API，根本没必要自己编译。现在公司项目需要在c++层调用Encode生成Webp，所以就自己编译，方便后续的更新和管理。其实Webp源码里面对不同OS的构建编译支持的
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>arm 指令</title>
    <link href="http://antyme.com/2018/04/02/arm-%E6%8C%87%E4%BB%A4/"/>
    <id>http://antyme.com/2018/04/02/arm-指令/</id>
    <published>2018-04-02T07:52:25.000Z</published>
    <updated>2018-04-04T06:57:01.790Z</updated>
    
    <content type="html"><![CDATA[<p>ASR、LSL、LSR、ROR 和 RRX<br>算术右移、逻辑左移、逻辑右移、向右循环移和带扩展向右循环移。</p>
<p>语法<br>op{S}{cond} Rd, Rm, Rs<br>op{S}{cond} Rd, Rm, #sh<br>RRX{S}{cond} Rd, Rm<br>其中：</p>
<p>op<br>是 ASR、LSL、LSR 或 ROR 之一。</p>
<p>S<br>是一个可选的后缀。 如果指定 S，则会更新运算结果的条件代码标记（请参阅条件执行）。</p>
<p>Rd<br>是目标寄存器。</p>
<p>Rm<br>是存放第一个操作数的寄存器。 此操作数将会被右移。</p>
<p>Rs<br>是存放移位值的寄存器，所存放的移位值应用于 Rm 中的值。 只使用最低有效字节。</p>
<p>sh<br>为一个常数移位值。 该值的允许范围由具体指令决定：</p>
<p>ASR<br>允许移动 1-32 位</p>
<p>LSL<br>允许移动 0-31 位</p>
<p>LSR<br>允许移动 1-32 位</p>
<p>ROR<br>允许移动 1-31 位</p>
<p>用法<br>ASR 提供除以 2 的幂后的寄存器内容的有符号值。 它可将符号位复制到左侧空出的位中。</p>
<p>LSL 提供乘以 2 的幂后的寄存器内容的值。LSR 提供除以 2 的可变次幂后的寄存器内容的无符号值。 这两个指令均会向空出的位中插入零。</p>
<p>ROR 可提供按某个值循环移位后的寄存器内容的值。 从右端移出的位将会被插入到左侧空出的位中。</p>
<p>RRX 可提供经右移一位后的寄存器中的值。 原先的进位标记将会移入位 [31]。 如果有 S 后缀，则将原先的位 [0] 存入进位标记中。</p>
<p>限制<br>使用 Rs 的 ARM 指令不得使用 r15。 Thumb 指令不得使用 r15 或 r13。</p>
<p>条件标记<br>如果指定了 S，则这些指令将会根据结果来更新 N 和 Z 标记。</p>
<p>如果移位值为 0，则不会影响 C 标记。否则，C 标记会更新为移出的最后一位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ASR、LSL、LSR、ROR 和 RRX&lt;br&gt;算术右移、逻辑左移、逻辑右移、向右循环移和带扩展向右循环移。&lt;/p&gt;
&lt;p&gt;语法&lt;br&gt;op{S}{cond} Rd, Rm, Rs&lt;br&gt;op{S}{cond} Rd, Rm, #sh&lt;br&gt;RRX{S}{cond} Rd
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>理解红黑树原理</title>
    <link href="http://antyme.com/2018/02/27/%E7%90%86%E8%A7%A3%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86/"/>
    <id>http://antyme.com/2018/02/27/理解红黑树原理/</id>
    <published>2018-02-27T09:31:51.000Z</published>
    <updated>2018-02-27T11:00:09.525Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/jz1ajDUygZ7sXLQFHyfjWA" target="_blank" rel="external">参考链接</a><br>先回顾下二叉查找树</p>
<ul>
<li>左子树上所有结点的值均小于或等于它的根结点的值。</li>
<li>右子树上所有结点的值均大于或等于它的根结点的值。</li>
<li>左、右子树也分别为二叉排序树。</li>
</ul>
<hr>
<ul>
<li>节点是红色或黑色。</li>
<li>根节点是黑色。</li>
<li>每个叶子节点都是黑色的空节点（NIL节点）。</li>
<li>每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li>
<li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。<br>&lt;!– - [ ] Eat</li>
</ul>
<ul>
<li>[x] Code<ul>
<li>[x] HTML</li>
<li>[x] CSS</li>
<li>[x] JavaScript</li>
</ul>
</li>
<li>[ ] Sleep –&gt;</li>
</ul>
<hr>
<h1 id="lt-–-Hello"><a href="#lt-–-Hello" class="headerlink" title="&lt;!– Hello"></a>&lt;!– Hello</h1><p>I like <a href="https://www.google.com/" target="_blank" rel="external">Google</a> –&gt;</p>
<p>下图中这棵树，就是一颗典型的二叉查找树：<br><img src="/images/BST.webp" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; size/<span class="keyword">sizeof</span>(<span class="keyword">void</span>*); ++idx)&#123;</div><div class="line">    <span class="keyword">char</span> *<span class="built_in">string</span> = (<span class="keyword">char</span>*)memory[idx];</div><div class="line"></div><div class="line">    NSString *str = [NSString stringWithUTF8String:<span class="built_in">string</span>];</div><div class="line">    <span class="keyword">if</span>(!str)<span class="keyword">continue</span>;</div><div class="line"></div><div class="line">    BHLog(@<span class="string">"config = %@"</span>, str);</div><div class="line">    <span class="keyword">if</span>(str) [configs addObject:str];</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/jz1ajDUygZ7sXLQFHyfjWA&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;参考链接&lt;/a&gt;&lt;br&gt;先回顾下二叉查找树&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左子树上所有结点的值均
    
    </summary>
    
    
      <category term="算法" scheme="http://antyme.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Mac命令行终端下使用shadowsocks翻墙</title>
    <link href="http://antyme.com/2018/01/20/Mac%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BB%88%E7%AB%AF%E4%B8%8B%E4%BD%BF%E7%94%A8shadowsocks%E7%BF%BB%E5%A2%99/"/>
    <id>http://antyme.com/2018/01/20/Mac命令行终端下使用shadowsocks翻墙/</id>
    <published>2018-01-20T09:53:08.000Z</published>
    <updated>2018-01-20T10:37:15.627Z</updated>
    
    <content type="html"><![CDATA[<p>很舒服！😝！</p>
<p><a href="http://www.cashqian.net/blog/001486989831982332565298e4942a2bb8f56b08f9d2475000" target="_blank" rel="external">Mac命令行终端下使用shadowsocks翻墙
</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很舒服！😝！&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cashqian.net/blog/001486989831982332565298e4942a2bb8f56b08f9d2475000&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;M
    
    </summary>
    
    
      <category term="工具" scheme="http://antyme.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>iOS图形对象理解</title>
    <link href="http://antyme.com/2017/04/17/iOS%E5%9B%BE%E5%BD%A2%E5%AF%B9%E8%B1%A1%E7%90%86%E8%A7%A3/"/>
    <id>http://antyme.com/2017/04/17/iOS图形对象理解/</id>
    <published>2017-04-17T03:11:20.000Z</published>
    <updated>2017-04-17T03:11:20.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Beehive源码简析</title>
    <link href="http://antyme.com/2017/04/08/SDK%E4%B8%AD%E4%B8%80%E6%AC%A1Beehive%E5%AE%9E%E8%B7%B5/"/>
    <id>http://antyme.com/2017/04/08/SDK中一次Beehive实践/</id>
    <published>2017-04-07T16:00:00.000Z</published>
    <updated>2017-04-11T12:27:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接：</p>
<p><a href="https://github.com/alibaba/BeeHive" target="_blank" rel="external">alibaba/BeeHive</a></p>
<p><a href="https://halfrost.com/beehive/" target="_blank" rel="external">BeeHive —— 一个优雅但还在完善中的解耦框架</a></p>
<h3 id="BeeHive概述"><a href="#BeeHive概述" class="headerlink" title="BeeHive概述"></a>BeeHive概述</h3><p><img src="/images/beehive.png" alt=""></p>
<p>BeeHive是用于iOS的App模块化编程的框架实现方案，吸收了Spring框架Service的理念来实现模块间的API耦合。</p>
<p>目前BeeHive v1.2.0 全部是利用Protocol的方式，实现了模块间解耦的目的：</p>
<ol>
<li>各个模块以插件的形式存在。每个都可独立，相互解耦。 </li>
<li>各个模块具体实现与接口调用分离 </li>
<li>各个模块也有生命周期，也可以进行管理。</li>
</ol>
<h3 id="BeeHive模块注册"><a href="#BeeHive模块注册" class="headerlink" title="BeeHive模块注册"></a>BeeHive模块注册</h3><p>先从模块的注册开始分析，来看看BeeHive是如何给各个模块进行注册的。</p>
<p>在BeeHive中是通过BHModuleManager来管理各个模块的。BHModuleManager中只会管理已经被注册过的模块。</p>
<p>注册Module的方式总共有三种：</p>
<h5 id="Annotation方式注册"><a href="#Annotation方式注册" class="headerlink" title="Annotation方式注册"></a>Annotation方式注册</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BeeHiveService(HomeServiceProtocol,BHViewController)</div></pre></td></tr></table></figure>
<p>BeeHiveService宏定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#define BeeHiveService(servicename,impl) \</div><div class="line">char * k##servicename##_service BeeHiveDATA(BeehiveServices) = &quot;&#123; \&quot;&quot;#servicename&quot;\&quot; : \&quot;&quot;#impl&quot;\&quot;&#125;&quot;;</div></pre></td></tr></table></figure>
<p>BeeHiveDATA又是一个宏：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define BeeHiveDATA(sectname) __attribute((used, section(&quot;__DATA,&quot;#sectname&quot; &quot;)))</div></pre></td></tr></table></figure>
<p>最终BeeHiveService宏会在预编译结束会完全展开成下面的样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">char * kHomeServiceProtocol_service __attribute((used, section(&quot;__DATA,&quot;&quot;BeehiveServices&quot;&quot; &quot;))) = &quot;&#123; \&quot;&quot;&quot;HomeServiceProtocol&quot;&quot;\&quot; : \&quot;&quot;&quot;BHViewController&quot;&quot;\&quot;&#125;&quot;;</div></pre></td></tr></table></figure>
<p>到这里__attribute((used,section(“segmentname,sectionname”)))就需要先说明2个地方。</p>
<p>__attribute第一个参数used很有用。这个关键字是用来修饰函数的。被used修饰以后，意味着即使函数没有被引用，在Release下也不会被优化。如果不加这个修饰，那么Release环境链接器下会去掉没有被引用的段。具体的描述可以看这个gun的<a href="https://gcc.gnu.org/onlinedocs/gcc-3.2/gcc/Variable-Attributes.html" target="_blank" rel="external">官方文档</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">section (&quot;section-name&quot;)</div><div class="line">Normally, the compiler places the objects it generates in sections like data and bss. Sometimes, however, you need additional sections, or you need certain particular variables to appear in special sections, for example to map to special hardware. The section attribute specifies that a variable (or function) lives in a particular section. For example, this small program uses several specific section names:</div><div class="line">          struct duart a __attribute__ ((section (&quot;DUART_A&quot;))) = &#123; 0 &#125;;</div><div class="line">          struct duart b __attribute__ ((section (&quot;DUART_B&quot;))) = &#123; 0 &#125;;</div><div class="line">          char stack[10000] __attribute__ ((section (&quot;STACK&quot;))) = &#123; 0 &#125;;</div><div class="line">          int init_data __attribute__ ((section (&quot;INITDATA&quot;))) = 0;</div><div class="line">          </div><div class="line">          main()</div><div class="line">          &#123;</div><div class="line">            /* Initialize stack pointer */</div><div class="line">            init_sp (stack + sizeof (stack));</div><div class="line">          </div><div class="line">            /* Initialize initialized data */</div><div class="line">            memcpy (&amp;init_data, &amp;data, &amp;edata - &amp;data);</div><div class="line">          </div><div class="line">            /* Turn on the serial ports */</div><div class="line">            init_duart (&amp;a);</div><div class="line">            init_duart (&amp;b);</div><div class="line">          &#125;</div><div class="line">          </div><div class="line">Use the section attribute with an initialized definition of a global variable, as shown in the example. GCC issues a warning and otherwise ignores the section attribute in uninitialized variable declarations.</div><div class="line"></div><div class="line">You may only use the section attribute with a fully initialized global definition because of the way linkers work. The linker requires each object be defined once, with the exception that uninitialized variables tentatively go in the common (or bss) section and can be multiply &quot;defined&quot;. You can force a variable to be initialized with the -fno-common flag or the nocommon attribute.</div><div class="line"></div><div class="line">Some file formats do not support arbitrary sections so the section attribute is not available on all platforms. If you need to map the entire contents of a module to a particular section, consider using the facilities of the linker instead.</div></pre></td></tr></table></figure>
<p>Static静态变量会按照他们申明的顺序，放到一个单独的段中。我们通过使用<strong>attribute</strong>((section(“name”)))来指明哪个段。数据则用<strong>attribute</strong>((used))来标记，防止链接器会优化删除未被使用的段。</p>
<p>再来具体说说section的作用。</p>
<p>编译器编译源代码后生成的文件叫目标文件，从文件结构上来说，它已经是编译后可执行的文件格式，只是还没有经过链接的过程。可执行文件(Executable)主要是Windows下的PE(Portable Executable)和Linux的ELF(Executable Linkable Format)，它们也都是COFF(Common file format)格式的变种。程序源程序代码被编译之后会主要分成两个段：程序指令和程序数据。代码段属于程序指令，数据段和.bss段属于数据段。</p>
<p>可执行文件结构图：</p>
<p><img src="/images/elf.png" alt=""></p>
<p>Module被这样存到了特殊的段中，那怎么取出来的呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">static NSArray&lt;NSString *&gt;* BHReadConfiguration(char *section)  </div><div class="line">&#123;</div><div class="line">    NSMutableArray *configs = [NSMutableArray array];</div><div class="line"></div><div class="line">    Dl_info info;</div><div class="line">    dladdr(BHReadConfiguration, &amp;info);</div><div class="line"></div><div class="line">#ifndef __LP64__</div><div class="line">    // const struct mach_header *mhp = _dyld_get_image_header(0); // both works as below line</div><div class="line">    const struct mach_header *mhp = (struct mach_header*)info.dli_fbase;</div><div class="line">    unsigned long size = 0;</div><div class="line">    // 找到之前存储的数据段(Module找BeehiveMods段 和 Service找BeehiveServices段)的一片内存</div><div class="line">    uint32_t *memory = (uint32_t*)getsectiondata(mhp, &quot;__DATA&quot;, section, &amp; size);</div><div class="line">#else /* defined(__LP64__) */</div><div class="line">    const struct mach_header_64 *mhp = (struct mach_header_64*)info.dli_fbase;</div><div class="line">    unsigned long size = 0;</div><div class="line">    uint64_t *memory = (uint64_t*)getsectiondata(mhp, &quot;__DATA&quot;, section, &amp; size);</div><div class="line">#endif /* defined(__LP64__) */</div><div class="line"></div><div class="line">    // 把特殊段里面的数据都转换成字符串存入数组中</div><div class="line">    for(int idx = 0; idx &lt; size/sizeof(void*); ++idx)&#123;</div><div class="line">        char *string = (char*)memory[idx];</div><div class="line"></div><div class="line">        NSString *str = [NSString stringWithUTF8String:string];</div><div class="line">        if(!str)continue;</div><div class="line"></div><div class="line">        BHLog(@&quot;config = %@&quot;, str);</div><div class="line">        if(str) [configs addObject:str];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return configs;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过调用这个static函数BHReadConfiguration，我们就可以拿到之前注册到BeehiveMods特殊段里面的各个Module的类名，都用字符串装在数据里。</p>
<h5 id="读取本地Pilst文件"><a href="#读取本地Pilst文件" class="headerlink" title="读取本地Pilst文件"></a>读取本地Pilst文件</h5><p>要读取本地的Plist文件之前，需要先设置好路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[BHContext shareInstance].moduleConfigName = @&quot;BeeHive.bundle/BeeHive&quot;;</div></pre></td></tr></table></figure></p>
<p><img src="/images/plist.png" alt=""></p>
<h5 id="Load方法注册"><a href="#Load方法注册" class="headerlink" title="Load方法注册"></a>Load方法注册</h5><p>最后一种注册Module的方法就是在Load方法里面注册Module的类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">+ (void)load</div><div class="line">&#123;</div><div class="line">    [BeeHive registerDynamicModule:[self class]];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)registerService:(Protocol *)service implClass:(Class)implClass</div><div class="line">&#123;</div><div class="line">    NSParameterAssert(service != nil);</div><div class="line">    NSParameterAssert(implClass != nil);</div><div class="line"></div><div class="line">    // impClass 是否遵循了 Protocol 协议</div><div class="line">    if (![implClass conformsToProtocol:service] &amp;&amp; self.enableException) &#123;</div><div class="line">        @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:[NSString stringWithFormat:@&quot;%@ module does not comply with %@ protocol&quot;, NSStringFromClass(implClass), NSStringFromProtocol(service)] userInfo:nil];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Protocol 协议是否已经注册过了</div><div class="line">    if ([self checkValidService:service] &amp;&amp; self.enableException) &#123;</div><div class="line">        @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:[NSString stringWithFormat:@&quot;%@ protocol has been registed&quot;, NSStringFromProtocol(service)] userInfo:nil];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    NSMutableDictionary *serviceInfo = [NSMutableDictionary dictionary];</div><div class="line">    [serviceInfo setObject:NSStringFromProtocol(service) forKey:kService];</div><div class="line">    [serviceInfo setObject:NSStringFromClass(implClass) forKey:kImpl];</div><div class="line"></div><div class="line">    [self.lock lock];</div><div class="line">    [self.allServices addObject:serviceInfo];</div><div class="line">    [self.lock unlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="BeeHive模块调用"><a href="#BeeHive模块调用" class="headerlink" title="BeeHive模块调用"></a>BeeHive模块调用</h3><p>在BeeHive中调用以下方法可以返回一个能相应Protocol的实例对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">- (id)createService:(Protocol *)proto;</div><div class="line"></div><div class="line">- (id)createService:(Protocol *)proto;</div><div class="line">&#123;</div><div class="line">    return [[BHServiceManager sharedManager] createService:proto];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)createService:(Protocol *)service</div><div class="line">&#123;</div><div class="line">    id implInstance = nil;</div><div class="line"></div><div class="line">    // Protocol 协议是否已经注册过了</div><div class="line">    if (![self checkValidService:service] &amp;&amp; self.enableException) &#123;</div><div class="line">        @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:[NSString stringWithFormat:@&quot;%@ protocol does not been registed&quot;, NSStringFromProtocol(service)] userInfo:nil];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Class implClass = [self serviceImplClass:service];</div><div class="line"></div><div class="line">    if ([[implClass class] respondsToSelector:@selector(shareInstance)])</div><div class="line">        implInstance = [[implClass class] shareInstance];</div><div class="line">    else</div><div class="line">        implInstance = [[implClass alloc] init];</div><div class="line"></div><div class="line">    if (![implInstance respondsToSelector:@selector(singleton)]) &#123;</div><div class="line">        return implInstance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    NSString *serviceStr = NSStringFromProtocol(service);</div><div class="line"></div><div class="line">    // 是否需要缓存</div><div class="line">    if ([implInstance singleton]) &#123;</div><div class="line">        id protocol = [[BHContext shareInstance] getServiceInstanceFromServiceName:serviceStr];</div><div class="line"></div><div class="line">        if (protocol) &#123;</div><div class="line">            return protocol;</div><div class="line">        &#125; else &#123;</div><div class="line">            [[BHContext shareInstance] addServiceWithImplInstance:implInstance serviceName:serviceStr];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125; else &#123;</div><div class="line">        [[BHContext shareInstance] addServiceWithImplInstance:implInstance serviceName:serviceStr];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return implInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法也会先检查Protocol协议是否是注册过的。然后接着取出字典里面对应的Class，如果实现了shareInstance方法，那么就生成一个单例出来，如果没有，那么就随便生成一个对象出来。如果还实现了singleton，就能进一步的把implInstance和serviceStr对应的加到BHContext的servicesByName字典里面缓存起来。这样就可以随着上下文传递了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通常会有三种形式的接口访问形式：</p>
<ul>
<li>基于接口的实现Service访问方式（Java spring框架实现）</li>
<li>基于函数调用约定实现的Export Method(PHP的extension，ReactNative的扩展机制)</li>
<li>基于跨应用实现的URL Route模式(iPhone App之间的互访)</li>
</ul>
<p>BeeHive目前只实现了第一种方式，后两种方式还需要继续完善。</p>
<p>基于接口Service访问的优点是可以编译时检查发现接口的变更，从而及时修正接口问题。缺点是需要依赖接口定义的头文件，通过模块增加得越多，维护接口定义的也有一定工作量。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/alibaba/BeeHive&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;alibaba/BeeHive&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://half
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS SDK cocoapod实践：源码管理和二进制发布</title>
    <link href="http://antyme.com/2017/04/07/iOS-SDK-cocoapod%E5%AE%9E%E8%B7%B5%EF%BC%9A%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8F%91%E5%B8%83/"/>
    <id>http://antyme.com/2017/04/07/iOS-SDK-cocoapod实践：源码管理和二进制发布/</id>
    <published>2017-04-07T06:42:49.000Z</published>
    <updated>2017-04-11T12:26:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接：</p>
<p><a href="http://www.infoq.com/cn/articles/cocoapods-binarization" target="_blank" rel="external">CocoaPods组件平滑二进制化解决方案</a></p>
<p><a href="http://guides.cocoapods.org/syntax/podspec.html" target="_blank" rel="external">Podspec Syntax Reference</a></p>
<p><a href="http://guides.cocoapods.org/syntax/podfile.html" target="_blank" rel="external">Podfile Syntax Reference</a></p>
<p><a href="https://objccn.io/issue-6-4/" target="_blank" rel="external">深入理解 CocoaPods</a></p>
<h3 id="认识SDK"><a href="#认识SDK" class="headerlink" title="认识SDK"></a>认识SDK</h3><p>无论负责桌面软件、服务端、前端、app还是其他偏应用层的产品，时至今日的代码工作者们基本都有第三方SDK或者开源库（.dll .a .framework .jar .so等）的使用经历，每个人对一个第三方库好不好用，专业不专业的评判侧重点不一样，但大致可以归为如下几个方面：</p>
<h5 id="感性："><a href="#感性：" class="headerlink" title="感性："></a>感性：</h5><ul>
<li>文件组织方式清晰明了</li>
<li>类名前缀和包命名或者缩写要一致</li>
<li>代码风格一定要一致</li>
<li>函数命名遵循共性，不要出现歧义或者违背大家的共识</li>
<li>代码注释要规范和清楚</li>
<li>SDK功能正确，编译无警告和错误，支持最新的特性</li>
</ul>
<h5 id="理性："><a href="#理性：" class="headerlink" title="理性："></a>理性：</h5><hr>
<ul>
<li>SDK集成成本</li>
<li>API调用简单</li>
<li>功能可以定制</li>
<li>便于调试</li>
<li>API回调参数明确</li>
<li>API稳定</li>
<li>参数命名一定要明确无歧义</li>
<li>自给自足，丰衣足食</li>
<li>SDK配置参数和接口入参分开</li>
<li>SDK参数：拼接的字符串</li>
<li>同一类参数，封装成model，隐藏属性，通过方法构造</li>
<li>API功能单一，减少类似enum的入参设计</li>
<li>用于查询的属性，绝对不能直接设置</li>
<li>API 回调设计</li>
</ul>
<h5 id="发布："><a href="#发布：" class="headerlink" title="发布："></a>发布：</h5><ul>
<li>SDK打包形式</li>
<li>发布渠道</li>
<li>文档</li>
<li>demo</li>
<li>接入帮助</li>
</ul>
<h5 id="Cocoapods："><a href="#Cocoapods：" class="headerlink" title="Cocoapods："></a>Cocoapods：</h5><p>上面这些点基本上可以衡量出一个SDK提供方走不走心，专不专业。作为iOS从业者，cocoapods这东西应该是无人不知无人不晓的（假如你真不知道，去搞Android吧），ObjC中国一篇深入理解cocoapods的文章中对cocoapods的功能描述：</p>
<blockquote>
<p>CocoaPods 是开发 OS X 和 iOS 应用程序的一个第三方库的依赖管理工具。利用 CocoaPods，可以定义自己的依赖关系 (称作 pods)，并且随着时间的变化，以及在整个开发环境中对第三方库的版本管理非常方便。</p>
<p>CocoaPods 背后的理念主要体现在两个方面。首先，在工程中引入第三方代码会涉及到许多内容。针对 Objective-C 初级开发者来说，工程文件的配置会让人很沮丧。在配置 build phases 和 linker flags 过程中，会引起许多人为因素的错误。CocoaPods 简化了这一切，它能够自动配置编译选项。</p>
<p>其次，通过 CocoaPods，可以很方便的查找到新的第三方库。当然，这并不是说你可以简单的将别人提供的库拿来拼凑成一个应用程序。它的真正作用是让你能够找到真正好用的库，以此来缩短我们的开发周期和提升软件的质量。</p>
</blockquote>
<p>根据常识，只要第三方库的开发者按照cocoapods指定的规范（<code>截止写这篇文章的时候，cocoapods官网显示有3万多个第三方库且有190多万的app引用了cocoapods中的这些库，App Store平台上的应用总数量是300万左右</code>）设计代码库，就可以提交至cocoapods仓库，供全球开发者们使用。但我们平时开发过程中使用的第三方库基本上都是开源库，大致原理就是<code>pod install</code>之后就是把第三方库的源码下载到本地，然后编译成一个framework，app链接这个framework来使用。</p>
<p>而我们是一家提供SDK的高科技公司！老板说我们最多只能把二进制放出去（老板，连二进制都不让放出去，你放我出去吧……），源码绝不能放出去！说实话还在试用期的我顿时陷入了懵逼状态，怎么办啊？要不直接放自己出去吧。。。</p>
<p>问题总是要解决的。于是上网搜索，平时各种方案细节细到让人感动的简书、知乎还有stackflow上尽然没找到……😢。InfoQ上找到了参考链接列出的那篇为了提升编译速度对第三方pod二进制化的文章。</p>
<h3 id="实现SDK"><a href="#实现SDK" class="headerlink" title="实现SDK"></a>实现SDK</h3><p>看完至仔细一想，我的二进制也是一堆源码编译完的，只不过是提前编译而已啊，这时我又想起了Bugtags，一个高级功能需要付费的bug管理SDK，它的pod就是以framework方式打包的。别人可以，我们没理由不行啊！废话不说了，开撸！撸之前先看下游戏规则：</p>
<blockquote>
<h4 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h4><p>Podfile</p>
<p>   Podfile 是一个文件，用于定义项目所需要使用的第三方库。该文件支持高度定制，你可以根据个人喜好对其做出定制。更多相关信息，请查阅 Podfile 指南。</p>
<p>Podspec</p>
<p>.podspec 也是一个文件，该文件描述了一个库是怎样被添加到工程中的。它支持的功能有：列出源文件、<code>framework、编译选项和某个库所需要的依赖</code>等。</p>
</blockquote>
<p>这是<a href="http://guides.cocoapods.org/syntax/podspec.html#specification" target="_blank" rel="external">guides.cocoapods</a>官网.podspec模板：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">Pod::Spec.new do |spec|</div><div class="line">  spec.name         = &apos;Reachability&apos;</div><div class="line">  spec.version      = &apos;3.1.0&apos;</div><div class="line">  spec.license      = &#123; :type =&gt; &apos;BSD&apos; &#125;</div><div class="line">  spec.homepage     = &apos;https://github.com/tonymillion/Reachability&apos;</div><div class="line">  spec.authors      = &#123; &apos;Tony Million&apos; =&gt; &apos;tonymillion@gmail.com&apos; &#125;</div><div class="line">  spec.summary      = &apos;ARC and GCD Compatible Reachability Class for iOS and OS X.&apos;</div><div class="line">  spec.source       = &#123; :git =&gt; &apos;https://github.com/tonymillion/Reachability.git&apos;, :tag =&gt; &apos;v3.1.0&apos; &#125;</div><div class="line">  spec.module_name  = &apos;Rich&apos;</div><div class="line"></div><div class="line">  spec.ios.deployment_target  = &apos;9.0&apos;</div><div class="line">  spec.osx.deployment_target  = &apos;10.10&apos;</div><div class="line"></div><div class="line">  spec.source_files       = &apos;Reachability/common/*.swift&apos;</div><div class="line">  spec.ios.source_files   = &apos;Reachability/ios/*.swift&apos;, &apos;Reachability/extensions/*.swift&apos;</div><div class="line">  spec.osx.source_files   = &apos;Reachability/osx/*.swift&apos;</div><div class="line"></div><div class="line">  spec.framework      = &apos;SystemConfiguration&apos;</div><div class="line">  spec.ios.framework  = &apos;UIKit&apos;</div><div class="line">  spec.osx.framework  = &apos;AppKit&apos;</div><div class="line"></div><div class="line">  spec.dependency &apos;SomeOtherPod&apos;</div><div class="line">end</div></pre></td></tr></table></figure>
<p>前面说的Bugtag的Bugtags.podspec文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">Pod::Spec.new do |s|</div><div class="line">  s.name         = &quot;Bugtags&quot;</div><div class="line">  s.version      = &quot;2.2.2&quot;</div><div class="line">  s.summary      = &quot;Bug reporting for mobile apps, improve your app anytime, anywhere. Learn more at http://bugtags.com.&quot;</div><div class="line">  s.homepage     = &quot;http://bugtags.com/&quot;</div><div class="line">  s.license      = &#123;</div><div class="line">      :type =&gt; &apos;Commercial&apos;,</div><div class="line">      :text =&gt; &lt;&lt;-LICENSE</div><div class="line">                Copyright (C) 2017 Bugtags.</div><div class="line">                Permission is hereby granted to use this framework as is, modification are not allowed.</div><div class="line">                All rights reserved.</div><div class="line">        </div><div class="line">        THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</div><div class="line">        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</div><div class="line">        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</div><div class="line">        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</div><div class="line">        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</div><div class="line">        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN</div><div class="line">        THE SOFTWARE.</div><div class="line">      LICENSE</div><div class="line">    &#125;</div><div class="line">  s.author              = &#123; &quot;Bugtags&quot; =&gt; &quot;dev@bugtags.com&quot; &#125;</div><div class="line">  s.platform            = :ios, &apos;6.0&apos;</div><div class="line">  s.source              = &#123; :git =&gt; &quot;https://github.com/bugtags/Bugtags-iOS.git&quot;, :tag =&gt; s.version.to_s &#125;</div><div class="line">  s.default_subspec     = &apos;Core&apos;</div><div class="line"></div><div class="line">  s.subspec &apos;Core&apos; do |ss|</div><div class="line">    ss.source_files        = &apos;Bugtags.framework/Versions/A/Headers/*.&#123;h&#125;&apos;</div><div class="line">    ss.resources           = &apos;Bugtags.bundle&apos;</div><div class="line">    ss.preserve_paths      = &apos;Bugtags.framework/*&apos;, &apos;Bugtags.bundle&apos;</div><div class="line">    ss.frameworks          = &apos;UIKit&apos;, &apos;ImageIO&apos;, &apos;AVFoundation&apos;, &apos;SystemConfiguration&apos;, &apos;CoreLocation&apos;, &apos;Security&apos;, &apos;CFNetwork&apos;, &apos;Bugtags&apos;</div><div class="line">    ss.libraries           = &apos;c++&apos;</div><div class="line">    ss.xcconfig            = &#123; &apos;FRAMEWORK_SEARCH_PATHS&apos; =&gt; &apos;&quot;$(PODS_ROOT)/Bugtags/&quot;&apos;, &apos;OTHER_LDFLAGS&apos; =&gt; &apos;-ObjC&apos; &#125;</div><div class="line">    ss.requires_arc        = true</div><div class="line">  end</div><div class="line"></div><div class="line">  s.subspec &apos;BugtagsInsta&apos; do |ss|</div><div class="line">    ss.dependency &apos;Bugtags/Core&apos;</div><div class="line">    ss.dependency &apos;BugtagsInsta&apos;</div><div class="line">  end</div><div class="line">end</div></pre></td></tr></table></figure>
<p>看完Bugtags.podspec之后，搞过c、c++或者类似Qt的人应该有一种似曾相识的感觉：这不就是一个makefile嘛，可以指定参与编译的源文件，编译选项和链接选项以及最终二进制文件支持的平台这些定制化的配置，这些配置会在<code>pod install</code>的时候全部写入到xcode的工程文件*.xcodeproj中。<code>坦白的说，我没有把podspec文件支持的所有参数都体验一遍，但在实现公司SDK pod化的过程中，所有的配置全部可以满足，例如-force_load这种一般pod很少用的链接选项。</code></p>
<p>按照上述模板或者上<a href="http://guides.cocoapods.org/syntax/podspec.html#subspec" target="_blank" rel="external">官网</a>和google基本可以实现运行在创建pod的时候默认生成的demo。但是这样还是没有满足发布二进制的需求啊！是的，上面所讲的是我们在开发过程中使用的podspec，这个是要放到内部源码管理工具中的，平时开发都是基于这个文件配置xcode环境的，所以是要共享的。那说好的发布二进制怎么办呢？</p>
<p>下面是一张app使用pod的依赖图（点击看大图）：</p>
<figure class="half"><br>    <a href="/images/pod.jpg"><img src="/images/pod.jpg" width="400" height="400"></a><br></figure>

<p>其实都到这个时候了，只要把开发过程中生成的product.framework发布出去就可以了。具体是怎么样的呢？先说下我们（正常人）平时的开发和发布流程，大致是这样的，其他人我不清楚：产品经理或者老板提要求（需求：实现一个无人驾驶飞机，下周一发布，不可以被打下来），我们（代码工作者）实现（一个怎么打都打不下来的无人驾驶飞机），开发完成发给老板（老板要验收，结果老板打了一个通宵都没打下来），老板说我们的飞机可以发布了，我们做了发布前的检查和验证（擦擦飞机上的液体，抚平机翼上的皱褶），发射。</p>
<p>大致流程说完了，开发完成，准备发布了（好开心）！我喜欢简单粗暴的方式（天生愚钝还没有想出更好的）：我准备了两份podfile：Podfile_dev和Podfile_product，两份podspecs：TupuTech.podspec_dev和TupuTech.podspec_product，具体怎么用呢？思路如下：</p>
<blockquote>
<p>开发的时候用Podfile_dev和TupuTech.podspec_dev，demo通过相对路径依赖本地开发pod，编译demo。在这个过程中我们的pod会编译成product.framework，这个framework就是我们需要发布的二进制SDK。<br>发布的时候用Podfile_product和TupuTech.podspec_product，修改podspec文件依赖源代码改成成依赖framework</p>
</blockquote>
<p>Podfile_dev文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">正在加载...</div></pre></td></tr></table></figure>
<p>TupuTech.podspec_dev文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">正在加载...</div></pre></td></tr></table></figure>
<p>Podfile_product文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">正在加载...</div></pre></td></tr></table></figure>
<p>TupuTech.podspec_product文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">正在加载...</div></pre></td></tr></table></figure>
<p>上面这些文件样子是什么样大致知道了，但是这些文件是什么时候相互替换的？怎么替换的？像这种繁琐易错的步骤最好给它脚本化，用脚本来做事最好的，shell、Python这些干这些真的太方便了，脚本化之后在准备开发或者发布的时候在代码根目录下执行这些脚本，自动帮你把这些环境配置好。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">#/bin/bash</div><div class="line"></div><div class="line">buildType=$1</div><div class="line">buildVersion=$2</div><div class="line"></div><div class="line">#更新podspec版本号</div><div class="line">if [ &quot;$buildType&quot; = &quot;product&quot; ]; then</div><div class="line">	echo &quot;product....&quot;</div><div class="line"></div><div class="line">	if [ ! $buildVersion ]; then</div><div class="line">	 echo &quot;请输入需要发布的版本号(eg:./build/build.sh product 1.5.0)&quot;</div><div class="line">	 exit</div><div class="line">	fi</div><div class="line"></div><div class="line">	#将版本号更新至对应的podspec和podfile文件中</div><div class="line">	python ./build/podspec.py ./build/podspecs/TupuTech.podspec_dev $buildVersion</div><div class="line">	python ./build/podspec.py ./build/podspecs/TupuTech.podspec_product $buildVersion</div><div class="line"></div><div class="line">	# python ./build/podfile.py ./build/podfiles/Podfile_dev $buildVersion</div><div class="line">	python ./build/podfile.py ./build/podfiles/Podfile_product $buildVersion</div><div class="line"></div><div class="line">	#依赖配置</div><div class="line">	...</div><div class="line">	...</div><div class="line"></div><div class="line">	#copy dev podfile、podspec至工程目录</div><div class="line">	cp build/podfiles/Podfile_dev tupu-iOS-demo/Podfile</div><div class="line">	cp build/podspecs/TupuTech.podspec_dev podspec/TupuTech.podspec</div><div class="line">	</div><div class="line">	#使用xcode命令行编译工具编译demo，顺便生成我们需要发布的framework至指定目录./Product</div><div class="line">	xcodebuild -workspace TuputechSDKDemo.xcworkspace -scheme TuputechSDKDemo -configuration Release -sdk iphonesimulator10.3  -derivedDataPath ./Product</div><div class="line">	xcodebuild -workspace TuputechSDKDemo.xcworkspace -scheme TuputechSDKDemo -configuration Release -sdk iphoneos10.3 -derivedDataPath ./Product</div><div class="line"> 	</div><div class="line">	cp -R Product/Build/Products/Release-iphoneos/TupuTech/TupuTech.framework Product</div><div class="line"></div><div class="line">	#合并真机指令集和模拟器指令集framework</div><div class="line">	lipo -output Product/TupuTech.framework/TupuTech -create Product/Build/Products/Release-iphoneos/TupuTech/TupuTech.framework/TupuTech Product/Build/Products/Release-iphonesimulator/TupuTech/TupuTech.framework/TupuTech</div><div class="line">	</div><div class="line">	#拷贝至发布前验证目录</div><div class="line">	mkdir -p ../podspec/TupuTech/InnerFrameworks</div><div class="line">	cp -R Product/TupuTech.framework ../podspec/TupuTech/InnerFrameworks/</div><div class="line"></div><div class="line">	#使用Product环境和新framework，编译demo验证framework</div><div class="line"> 	cd ../</div><div class="line"> 	cp build/podspecs/TupuTech.podspec_product podspec/TupuTech.podspec</div><div class="line"></div><div class="line">	echo &quot;Success: product....&quot;</div><div class="line">else	</div><div class="line">	echo &quot;dev....&quot;</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>至此，podspec/TupuTech/InnerFrameworks/TupuTech.framework和podspec/TupuTech.podspec就是我们需要发布的内容。</p>
<p>SDK是可以发布了，代码又是怎么跟踪管理的呢？我们知道TupuTech.podspec文件是要提交至Cocoapods，demo、TupuTech.framewor需要提交至类似github这种公开的代码仓库中供用户下载的，源码需要放在公司内部代码服务器上。好乱有木有？<br>接下来我会再分享一下怎么解决上面这么乱的代码跟踪以及一个阿里巴巴开源的叫做BeeHive的库是如何在我们SDK中发挥其意义的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.infoq.com/cn/articles/cocoapods-binarization&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CocoaPods组件平滑二进制化解决方案&lt;/a&gt;&lt;/
    
    </summary>
    
    
      <category term="iOS 组件化" scheme="http://antyme.com/tags/iOS-%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>常用数据结构、排序算法算法的时间复杂度</title>
    <link href="http://antyme.com/2016/12/23/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>http://antyme.com/2016/12/23/常用数据结构、排序算法算法的时间复杂度/</id>
    <published>2016-12-23T08:58:53.000Z</published>
    <updated>2016-12-23T09:17:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/xiangzhihong8/article/details/51547835" target="_blank" rel="external">阅读原文</a></p>
<p>这篇是原样抄过来的，为了自己在使用的过程中可以随时查看并迅速做出选择，希望原作者可以原谅哦！如果需要深入代码学习不同的数据结构和算法，还是点击原文回去看吧，原文有每个数据结构、算法对应的详解链接。</p>
<p>在我们实际开发过程中，遇到比较多的场景并不是需要自己造这些轮子（算法或者数据结构），更多的是需要自己根据实际业务场景(内存占用限制，速度要求)做出选择，例如根据查找、插入、删除和遍历等不同的使用频率选择不同的数据结构。</p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p><img src="http://oi7r83q55.bkt.clouddn.com/QQ20161223-2.png" alt=""></p>
<h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><p><img src="http://oi7r83q55.bkt.clouddn.com/QQ20161223-1.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/xiangzhihong8/article/details/51547835&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;阅读原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇是原样抄过来的，为了自己在使用的过程
    
    </summary>
    
    
      <category term="算法/iOS/c/c++" scheme="http://antyme.com/tags/%E7%AE%97%E6%B3%95-iOS-c-c/"/>
    
  </entry>
  
  <entry>
    <title>iOS Blocks的实现原理</title>
    <link href="http://antyme.com/2016/12/18/iOS-Blocks%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://antyme.com/2016/12/18/iOS-Blocks的实现原理/</id>
    <published>2016-12-18T07:56:04.000Z</published>
    <updated>2016-12-23T09:19:03.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Block的实质"><a href="#Block的实质" class="headerlink" title="Block的实质"></a>Block的实质</h4><p>Blocks.m文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int main() &#123;</div><div class="line">    void (^blk)() = ^&#123;</div><div class="line">//        printf(&quot;Hello Blocks&quot;);</div><div class="line">        int i = 0;</div><div class="line">        i = i + 1;</div><div class="line">    &#125;;</div><div class="line">    blk();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在命令行执行：</p>
<blockquote>
<p>clang -rewrite-objc Blocks.m</p>
</blockquote>
<p>通过clang(LLVM编译器)将含有Block语法的源代码（Blocks.m）转换为c++的源代码（Blocks.cpp）。</p>
<p>Blocks.cpp文件（截取跟理解相关的代码）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">#ifndef BLOCK_IMPL</div><div class="line">#define BLOCK_IMPL</div><div class="line">struct __block_impl &#123;</div><div class="line">  void *isa;</div><div class="line">  int Flags;</div><div class="line">  int Reserved;</div><div class="line">  void *FuncPtr;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line"></div><div class="line"></div><div class="line">        int i = 0;</div><div class="line">        i = i + 1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div><div class="line">int main() &#123;</div><div class="line">    void (*blk)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</div><div class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>转换之后就是正儿八经的c语言代码了，这指针，这结构体，这带static的方法，c语言的标配啊！😁</p>
<h4 id="Block捕获变量（局部变量、static变量、-block变量）原理"><a href="#Block捕获变量（局部变量、static变量、-block变量）原理" class="headerlink" title="Block捕获变量（局部变量、static变量、__block变量）原理"></a>Block捕获变量（局部变量、static变量、__block变量）原理</h4><p><code>未完待续</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Block的实质&quot;&gt;&lt;a href=&quot;#Block的实质&quot; class=&quot;headerlink&quot; title=&quot;Block的实质&quot;&gt;&lt;/a&gt;Block的实质&lt;/h4&gt;&lt;p&gt;Blocks.m文件：&lt;/p&gt;
&lt;figure class=&quot;highlight plain
    
    </summary>
    
    
      <category term="iOS/Objective-C" scheme="http://antyme.com/tags/iOS-Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket协议、SocketRocket源码学习</title>
    <link href="http://antyme.com/2016/12/14/WebSocket%E5%8D%8F%E8%AE%AE-SocketRocket%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://antyme.com/2016/12/14/WebSocket协议-SocketRocket源码学习/</id>
    <published>2016-12-14T08:36:44.000Z</published>
    <updated>2016-12-15T09:23:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://tools.ietf.org/html/rfc6455#section-5.5.1" target="_blank" rel="external">rfc6455 WebSockets 标准</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/WebSockets/Writing_WebSocket_servers" target="_blank" rel="external">编写 WebSocket 服务器</a></p>
<h3 id="WebSocket概述、握手"><a href="#WebSocket概述、握手" class="headerlink" title="WebSocket概述、握手"></a>WebSocket概述、握手</h3><p>首先，服务器必须通过标准 TCP 套接字来侦听外来的连接请求。取决于你的平台，可能已经处理好握手了。举个例子，我们假定你的服务监听在地址 example.com ，端口号 8000 上，而且能够回应路径 /chat 上的 GET 请求。</p>
<blockquote>
<p>警告: 服务器监听任意所选择的端口，但是如果在 80 或者 443 之外的端口上，可能会在防火墙或者代理上出问题。在 443 端口上比较容易成功，但是需要安全连接（TLS/SSL）。另外就是大多数浏览器（比如 Firefox 8+）不允许在安全页面上连接不安全的 WebSocket 服务器。</p>
</blockquote>
<p>握手这一环节就是 WebSockets 上的“web”。它是从 HTTP 到 WS 的桥梁。握手时会协商连接的详细信息，并且如果条件不适合，任何一方都可以在成功建立连接之前退出。服务器一定要清楚客户端所要求的一切信息，否则可能会发生安全问题。</p>
<h5 id="客户端握手请求"><a href="#客户端握手请求" class="headerlink" title="客户端握手请求"></a>客户端握手请求</h5><p>即使你正在构建一个服务，WebSocket 握手请求仍需要由客户端发起。因此你必须知道如何解读客户端信息。首先客户端会发送类似这样的标准 HTTP 请求（HTTP 版本号最低为 1.1 ，而且请求方法必须为 GET）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">GET /chat HTTP/1.1</div><div class="line">Host: example.com:8000</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</div><div class="line">Sec-WebSocket-Version: 13</div></pre></td></tr></table></figure>
<p>客户端可以请求扩展和/或子协议化，详见<a href="https://developer.mozilla.org/zh-CN/docs/WebSockets/Writing_WebSocket_servers#Miscellaneous" target="_blank" rel="external">杂项</a>。另外，常规的头部信息如User-Agent,Referer, Cookie, or authentication 等也可能会出现。你可以随意处理这些内容，它们并不直接属于WebScoket的一部分，忽略它们也没事。在许多的常见设置中，反向代理已经对它们进行了处理。</p>
<p>如果存在任何未知或者错误的请求头，服务器应该发送一个 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#400" target="_blank" rel="external">“400 Bad Request”</a>并立即关闭 socket。像往常一样，也可以在HTTP响应体中给出握手失败的原因，但是这个消息可能从来都不会显示出来 (浏览器不显示)。 如果服务器无法理解请求的WebSockets的版本，它应该发送一个包含它能理解的版本号的Sec-WebSocket-Version的头部信息。 (本指南解释了最新版本的v13)。现在让我们来了解一下最让人期待的头部信息，Sec-WebSocket-Key。</p>
<blockquote>
<p><em>提示: 所有的浏览器都会发送 Origin 请求头，你可以用它来处理安全问题（比如黑名单，白名单，origin检查之类的）然后发送回去 403 Forbidden 来禁止连接。但是要注意，非浏览器客户端可以发送伪造的 Origin。大多数应用如果没有检测到 Origin 请求头将会拒绝请求。</em></p>
<p><em>提示: 请求地址 (例如这里是 /chat ) 在规范中没有明确定义。所以许多人巧妙的利用这点，让一个服务器处理多个 WebSocket 应用。例如在 example.com/chat 上是一个聊天室，与此同时在 /game 上运行一个多人联机游戏。</em></p>
<p><em>注意: 常规 HTTP 状态码 只能在握手前使用。握手成功后，你就得用不同的代码了 (参阅规范的第7章第4节 ).</em></p>
</blockquote>
<h5 id="服务器握手响应"><a href="#服务器握手响应" class="headerlink" title="服务器握手响应"></a>服务器握手响应</h5><p>服务器收到握手请求后，就应该发送一个看起来很怪异 (但是仍然是 HTTP ) 的响应，就像这样：(记得每一个响应头之间用 \r\n 间隔，最后再放一个 \r\n 空行)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 101 Switching Protocols</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</div></pre></td></tr></table></figure>
<p>此外，服务器在这里也可以指明 扩展/子协议，具体参考 杂项。其中的 Sec-WebSocket-Accept 比较有意思。要生成它，将客户端提供的 Sec-WebSocket-Key 和规定中指明的 魔法字符串 “258EAFA5-E914-47DA-95CA-C5AB0DC85B11” 简单地连在一起，进行 SHA-1 Hash，然后用 base64 编码，返回结果即可。</p>
<blockquote>
<p>仅供参考: 这个过程对于判断服务器是否支持WebSockets这个很明显的事情来说可能显得太过复杂。但是，这非常重要，如果服务器接受了一个WebSockets的链接却按照HTTP请求来解析可能会带来安全上的问题。</p>
</blockquote>
<p>所以假设客户端发来的是 “dGhlIHNhbXBsZSBub25jZQ==”，服务器就回复 “s3pPLMBiTxaQ9kYGzzhZRbK+xOo=”。一旦服务器发送完这些响应头，连接就建立了，可以开始交换数据了。</p>
<blockquote>
<p>当然服务器也可以发送 Set-Cookie 之类的头，或者关于认证的请求，或者通过其他状态码重定向，总之只要在握手响应信息发出之前都可以。</p>
</blockquote>
<h5 id="持续追踪客户端"><a href="#持续追踪客户端" class="headerlink" title="持续追踪客户端"></a>持续追踪客户端</h5><p>这部分和Websocket协议没有直接关系，但请务必注意：你的服务器必须持续追踪每个客户端的socket以避免进行重复的握手。同一个客户IP地址可能尝试连接多次（但服务器为保护自己免受DoS拒绝服务式攻击，也可拒绝那些过多请求连接的客户端）。</p>
<h3 id="WebSocket协议"><a href="#WebSocket协议" class="headerlink" title="WebSocket协议"></a>WebSocket协议</h3><blockquote>
<p>我们知道客户端和服务端都能在任意时候发送数据——这是WebSocket的神奇之处，而且不管数据是从客户端-&gt;服务端，还是从服务端-&gt;客户端，每个数据帧（包）的格式都是一样的，如下表所示：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">0                   1                   2                   3</div><div class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</div><div class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</div><div class="line">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</div><div class="line">|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</div><div class="line">|N|V|V|V|       |S|             |   (if payload len==126/127)   |</div><div class="line">| |1|2|3|       |K|             |                               |</div><div class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</div><div class="line">|     Extended payload length continued, if payload len == 127  |</div><div class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</div><div class="line">|                               |Masking-key, if MASK set to 1  |</div><div class="line">+-------------------------------+-------------------------------+</div><div class="line">| Masking-key (continued)       |          Payload Data         |</div><div class="line">+-------------------------------- - - - - - - - - - - - - - - - +</div><div class="line">:                     Payload Data continued ...                :</div><div class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</div><div class="line">|                     Payload Data continued ...                |</div><div class="line">+---------------------------------------------------------------+</div><div class="line"></div><div class="line">		websocket协议（数据帧格式）</div></pre></td></tr></table></figure>
<blockquote>
<p>1、字段FIN：FIN 位和操作码字段共同起到把一个报文分成几个数据帧发送的作用。这就叫做报文分段，分段只在操作码为 0x0、0x1、0x2 时有效。下面demo-1详细介绍其用法。</p>
<p>2、字段RSV1、RSV2、RSV3可忽略，那是用于扩展的保留字段。</p>
<p>3、字段opcode：操作码(opcode) 字段定义怎样解释负载数据： 字段定义了如何解释有效负载数据:  0x0 为继续，0x1 文本 (以 utf-8 编码)，0x2 为二进制数据，和后面将要讨论的其他所谓”控制代码”。在此版本的 Websocket（当前版本号为13），0x3 到 0x7 和 0xB 到 0xF 无意义。<br><br></p>
<ul>
<li>0x00：表示这帧是连续的帧，应该把这帧的负载数据连接到接收的上一帧，下面demo1描述了具体的用法。<br><br></li>
<li>0x01：负载数据是文本。<br><br></li>
<li>0x02：负载数据是二进制数据。<br><br></li>
<li>0x08：关闭连接的请求帧，要关闭一个连接的话，客户端或者服务端可以发送一个带有一段特殊控制序列数据的控制帧，来开始挥手过程。一旦接收到这样的帧，另一方发送关闭帧作为回应。任何关闭连接之后的数据将被废弃。（我在调试的时候这个值等于’\b’，知道为什么吗😝）<br><br></li>
<li>0x9：Ping包，在握手后的任何一个时间点，客户端或者服务器可以选择发送一个ping包给对方。<br> <br></li>
<li>0xA：Pong包，当ping包被收到时，接受者必须尽可能快的发回pong包。例如，你可以使用这个机制来确定客户端仍然处于连接状态。</li>
</ul>
<p>4、字段MASK：MASK字段表明报文是否被编码（按：即前述XOR异或加密）。客户端发来的消息应该被掩蔽，所以你的服务器应该期待这个位为1。（事实上，<a href="https://tools.ietf.org/html/rfc6455#section-5.1节" target="_blank" rel="external">rfc6455 websocket规范的5.1</a>说如客户端发来“未掩蔽”的报文那服务端应该断开这个连接。）服务端回报文给客户端则不要掩蔽数据，相应的MASK位为0。稍后我们将解释掩蔽。注意：即使在一个安全套接字上传输数据，也要遵守上述规则。</p>
<p>5、字段Payload len（9-15位）：读取负载数据，需要知道读到那里为止。因此获知负载数据长度很重要。这个过程稍微有点复杂，要以下这些步骤：</p>
<ul>
<li>读取9-15位 (包括9和15位本身)，并转换为无符号整数。如果值小于或等于125，这个值就是长度；如果是 126，请转到步骤 2。如果它是 127，请转到步骤 3。</li>
<li>读取接下来的 16 位并转换为无符号整数，并作为长度。</li>
<li>读取接下来的 64 位并转换为无符号整数 (最高有效位必须为0)，并作为长度。</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Client: FIN=1, opcode=0x1, msg=&quot;hello&quot;</div><div class="line">Server: (process complete message immediately) Hi.</div><div class="line">Client: FIN=0, opcode=0x1, msg=&quot;and a&quot;</div><div class="line">Server: (listening, new message containing text started)</div><div class="line">Client: FIN=0, opcode=0x0, msg=&quot;happy new&quot;</div><div class="line">Server: (listening, payload concatenated to previous message)</div><div class="line">Client: FIN=1, opcode=0x0, msg=&quot;year!&quot;</div><div class="line">Server: (process complete message) Happy new year to you too!</div><div class="line"></div><div class="line">				demo-1</div></pre></td></tr></table></figure>
<p>demo-1描述服务器如何回应客户端发送的文本数据。第一个报文发送了单个数据帧，而第二个报文通过三帧发送。</p>
<h3 id="WebSocket-iOS开源库SocketRocket源码学习（facebook）"><a href="#WebSocket-iOS开源库SocketRocket源码学习（facebook）" class="headerlink" title="WebSocket iOS开源库SocketRocket源码学习（facebook）"></a>WebSocket iOS开源库SocketRocket源码学习（<a href="https://github.com/facebook/SocketRocket" target="_blank" rel="external">facebook</a>）</h3><p>所有学习方法中有一条比较高效的就是理论联系实际（代码）。iOS开发中用的比较多的是websocket库是Socket.IO-Client-Swift和Facebook开源的SocketRocket，刚开始准备研究学习第一个，发现Socket.IO-Client与我们自己服务端提供的接口适配有点问题，而且看了下源代码，默认会在path后面强制插入’/‘，而且请求的path也会强制处理，没有提供自定义的机会，搞了一上午都连不上。在继续之前尝试了一下SocketRocket，哇塞，不要太爽，不愧是Facebook啊！于是立即“悬崖勒马”，用这篇文章记录下自己的收获和理解。</p>
<p>下面的代码片段来自于SocketRocket源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (void)_initializeStreams;</div><div class="line">&#123;</div><div class="line">    assert(_url.port.unsignedIntValue &lt;= UINT32_MAX);</div><div class="line">    uint32_t port = _url.port.unsignedIntValue;</div><div class="line">    if (port == 0) &#123;</div><div class="line">        if (!_secure) &#123;</div><div class="line">            port = 80;</div><div class="line">        &#125; else &#123;</div><div class="line">            port = 443;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    NSString *host = _url.host;</div><div class="line">    </div><div class="line">    CFReadStreamRef readStream = NULL;</div><div class="line">    CFWriteStreamRef writeStream = NULL;</div><div class="line">    </div><div class="line">    CFStreamCreatePairWithSocketToHost(NULL, (__bridge CFStringRef)host, port, &amp;readStream, &amp;writeStream);//创建了socket通信的输入和输出流</div><div class="line">    </div><div class="line">    _outputStream = CFBridgingRelease(writeStream);</div><div class="line">    _inputStream = CFBridgingRelease(readStream);</div><div class="line">    </div><div class="line">    //@protocol NSStreamDelegate &lt;NSObject&gt;</div><div class="line">	//	@optional</div><div class="line">	//	- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode;</div><div class="line">	// @end</div><div class="line">    _inputStream.delegate = self;</div><div class="line">    _outputStream.delegate = self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>_initializeStreams方法创建了socket通信的输入和输出stream。但是，请看Apple文档对CFStreamCreatePairWithSocketToHost方法的说明，很重要。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Creates readable and writable streams connected to a TCP/IP port of a particular host.</div><div class="line">The streams do not create a socket, resolve the hostname, or connect to the remote host until you open one of the streams.</div><div class="line">Most properties are shared by both streams. Setting a shared property for one stream automatically sets the property for the other.</div></pre></td></tr></table></figure>
<blockquote>
<p>我大致翻译一下（尴尬）：这个方法在本机与使用TCP/IP端口的对方主机之间仅仅创建了用来写入和读取数据的两个流。但是这些流并没有创建真正的socket，没有开始解析这个host，也没有开始连接对方主机，上述这些操作会在调用open的时候执行。这两个流会共享大多数的属性。只要修改的属性恰好是它们共享的，在它们任何一个中进行修改，都会自动把该属性修改之后的值同步给另外一方。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)openConnection;</div><div class="line">&#123;</div><div class="line">    [self _updateSecureStreamOptions];</div><div class="line">    </div><div class="line">    if (!_scheduledRunloops.count) &#123;</div><div class="line">        [self scheduleInRunLoop:[NSRunLoop SR_networkRunLoop] forMode:NSDefaultRunLoopMode];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    [_outputStream open];</div><div class="line">    [_inputStream open];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这段代码才开始进行真正的连接。</p>
<p>下面这段是Apple文档对NSStreamDelegate的描述。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@protocol NSStreamDelegate &lt;NSObject&gt;</div><div class="line">@optional</div><div class="line">- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode;</div><div class="line">@end</div></pre></td></tr></table></figure>
<blockquote>
<p>The delegate receives this message when a given event has occurred on a given stream.<br>The delegate receives this message only if theStream is scheduled on a run loop. The message is sent on the stream object’s thread. The delegate should examine streamEvent to determine the appropriate action it should take.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode;</div><div class="line">&#123;</div><div class="line">	...</div><div class="line">    [weakSelf safeHandleEvent:eventCode stream:aStream];</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)safeHandleEvent:(NSStreamEvent)eventCode stream:(NSStream *)aStream</div><div class="line">&#123;</div><div class="line">        switch (eventCode) &#123;</div><div class="line">            case NSStreamEventOpenCompleted: &#123;</div><div class="line">	            ...</div><div class="line">	            ...</div><div class="line">	            [self didConnect];</div><div class="line">	            ...</div><div class="line">                [self _pumpWriting];</div><div class="line">                [self _pumpScanner];</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">                </div><div class="line">            case NSStreamEventErrorOccurred: &#123;</div><div class="line">	            ...</div><div class="line">	            ...</div><div class="line">                break;                </div><div class="line">            &#125;</div><div class="line">                </div><div class="line">            case NSStreamEventEndEncountered: &#123;</div><div class="line">                [self _pumpScanner];</div><div class="line">                ...</div><div class="line">                ...</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">                </div><div class="line">            case NSStreamEventHasBytesAvailable: &#123;</div><div class="line">                ...</div><div class="line">                ...</div><div class="line">                [self _pumpScanner];</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">                </div><div class="line">            case NSStreamEventHasSpaceAvailable: &#123;</div><div class="line">	            ...</div><div class="line">	            ...</div><div class="line">                [self _pumpWriting];</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">                </div><div class="line">            default:</div><div class="line">                SRFastLog(@&quot;(default)  %@&quot;, aStream);</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">- (void)didConnect;</div><div class="line">&#123;</div><div class="line">    SRFastLog(@&quot;Connected&quot;);</div><div class="line">    CFHTTPMessageRef request = CFHTTPMessageCreateRequest(NULL, CFSTR(&quot;GET&quot;), (__bridge CFURLRef)_url, kCFHTTPVersion1_1);</div><div class="line">    </div><div class="line">    // Set host first so it defaults</div><div class="line">    CFHTTPMessageSetHeaderFieldValue(request, CFSTR(&quot;Host&quot;), (__bridge CFStringRef)(_url.port ? [NSString stringWithFormat:@&quot;%@:%@&quot;, _url.host, _url.port] : _url.host));</div><div class="line">        </div><div class="line">    NSMutableData *keyBytes = [[NSMutableData alloc] initWithLength:16];</div><div class="line">    SecRandomCopyBytes(kSecRandomDefault, keyBytes.length, keyBytes.mutableBytes);</div><div class="line">    </div><div class="line">    if ([keyBytes respondsToSelector:@selector(base64EncodedStringWithOptions:)]) &#123;</div><div class="line">        _secKey = [keyBytes base64EncodedStringWithOptions:0];</div><div class="line">    &#125; else &#123;</div><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored &quot;-Wdeprecated-declarations&quot;</div><div class="line">        _secKey = [keyBytes base64Encoding];</div><div class="line">#pragma clang diagnostic pop</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    assert([_secKey length] == 24);</div><div class="line"></div><div class="line">    // Apply cookies if any have been provided</div><div class="line">    NSDictionary * cookies = [NSHTTPCookie requestHeaderFieldsWithCookies:[self requestCookies]];</div><div class="line">    for (NSString * cookieKey in cookies) &#123;</div><div class="line">        NSString * cookieValue = [cookies objectForKey:cookieKey];</div><div class="line">        if ([cookieKey length] &amp;&amp; [cookieValue length]) &#123;</div><div class="line">            CFHTTPMessageSetHeaderFieldValue(request, (__bridge CFStringRef)cookieKey, (__bridge CFStringRef)cookieValue);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    // set header for http basic auth</div><div class="line">    if (_url.user.length &amp;&amp; _url.password.length) &#123;</div><div class="line">        NSData *userAndPassword = [[NSString stringWithFormat:@&quot;%@:%@&quot;, _url.user, _url.password] dataUsingEncoding:NSUTF8StringEncoding];</div><div class="line">        NSString *userAndPasswordBase64Encoded;</div><div class="line">        if ([keyBytes respondsToSelector:@selector(base64EncodedStringWithOptions:)]) &#123;</div><div class="line">            userAndPasswordBase64Encoded = [userAndPassword base64EncodedStringWithOptions:0];</div><div class="line">        &#125; else &#123;</div><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored &quot;-Wdeprecated-declarations&quot;</div><div class="line">            userAndPasswordBase64Encoded = [userAndPassword base64Encoding];</div><div class="line">#pragma clang diagnostic pop</div><div class="line">        &#125;</div><div class="line">        _basicAuthorizationString = [NSString stringWithFormat:@&quot;Basic %@&quot;, userAndPasswordBase64Encoded];</div><div class="line">        CFHTTPMessageSetHeaderFieldValue(request, CFSTR(&quot;Authorization&quot;), (__bridge CFStringRef)_basicAuthorizationString);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    CFHTTPMessageSetHeaderFieldValue(request, CFSTR(&quot;Upgrade&quot;), CFSTR(&quot;websocket&quot;));</div><div class="line">    CFHTTPMessageSetHeaderFieldValue(request, CFSTR(&quot;Connection&quot;), CFSTR(&quot;Upgrade&quot;));</div><div class="line">    CFHTTPMessageSetHeaderFieldValue(request, CFSTR(&quot;Sec-WebSocket-Key&quot;), (__bridge CFStringRef)_secKey);</div><div class="line">    CFHTTPMessageSetHeaderFieldValue(request, CFSTR(&quot;Sec-WebSocket-Version&quot;), (__bridge CFStringRef)[NSString stringWithFormat:@&quot;%ld&quot;, (long)_webSocketVersion]);</div><div class="line">    </div><div class="line">    CFHTTPMessageSetHeaderFieldValue(request, CFSTR(&quot;Origin&quot;), (__bridge CFStringRef)_url.SR_origin);</div><div class="line">    </div><div class="line">    if (_requestedProtocols) &#123;</div><div class="line">        CFHTTPMessageSetHeaderFieldValue(request, CFSTR(&quot;Sec-WebSocket-Protocol&quot;), (__bridge CFStringRef)[_requestedProtocols componentsJoinedByString:@&quot;, &quot;]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    [_urlRequest.allHTTPHeaderFields enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123;</div><div class="line">        CFHTTPMessageSetHeaderFieldValue(request, (__bridge CFStringRef)key, (__bridge CFStringRef)obj);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    NSData *message = CFBridgingRelease(CFHTTPMessageCopySerializedMessage(request));</div><div class="line">    </div><div class="line">    CFRelease(request);</div><div class="line"></div><div class="line">    [self _writeData:message];//socket连接成功，发送客户端websocket握手请求</div><div class="line">    [self _readHTTPHeader];//等待并开始读取服务器websocket握手响应</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (void)_readHTTPHeader;</div><div class="line">&#123;</div><div class="line">    if (_receivedHTTPHeaders == NULL) &#123;</div><div class="line">        _receivedHTTPHeaders = CFHTTPMessageCreateEmpty(NULL, NO);</div><div class="line">    &#125;</div><div class="line">                        </div><div class="line">    [self _readUntilHeaderCompleteWithCallback:^(SRWebSocket *self,  NSData *data) &#123;</div><div class="line">        CFHTTPMessageAppendBytes(_receivedHTTPHeaders, (const UInt8 *)data.bytes, data.length);</div><div class="line">        </div><div class="line">        if (CFHTTPMessageIsHeaderComplete(_receivedHTTPHeaders)) &#123;</div><div class="line">            SRFastLog(@&quot;Finished reading headers %@&quot;, CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(_receivedHTTPHeaders)));</div><div class="line">            [self _HTTPHeadersDidFinish];</div><div class="line">        &#125; else &#123;</div><div class="line">            [self _readHTTPHeader];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我本地debug收到服务器返回的response header数据如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 101 Switching Protocols</div><div class="line">Server: Tengine/2.1.2</div><div class="line">Date: Thu, 15 Dec 2016 08:32:40 GMT</div><div class="line">Connection: upgrade</div><div class="line">Upgrade: websocket</div><div class="line">Sec-WebSocket-Accept: 0EDYPFTXV+u3rkKflAelaATKEvA=</div><div class="line">&lt;space-space-space-space-space-space-space-space-space-space</div></pre></td></tr></table></figure>
<p>最后一行是一个空白行,所以判断是http header是否结束的标志就是”\r\n\r\n”，请查看源码1262行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (void)_HTTPHeadersDidFinish;</div><div class="line">&#123;</div><div class="line">    NSInteger responseCode = CFHTTPMessageGetResponseStatusCode(_receivedHTTPHeaders);    </div><div class="line">    if (responseCode &gt;= 400) &#123;</div><div class="line">	    ...</div><div class="line">	    ...</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">	...    </div><div class="line">    self.readyState = SR_OPEN;    </div><div class="line">    if (!_didFail) &#123;</div><div class="line">        [self _readFrameNew];//websocket协商完毕，开始读取正式数据。</div><div class="line">    &#125;</div><div class="line">    [self _performDelegateBlock:^&#123;</div><div class="line">        if ([self.delegate respondsToSelector:@selector(webSocketDidOpen:)]) &#123;</div><div class="line">            [self.delegate webSocketDidOpen:self];</div><div class="line">        &#125;;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>截止到这里，websocket协商完毕，开始读取正式数据。当时代码看到这里的时候我也消除了一个内心的疑惑，为什么对面Android同事在websocket连接过程中http抓包软件可以抓到，而我用SocketRocket则完全抓不到？原因就是：我们iOS手机与服务器之间已经建立了一条长连接，然后自己组装websocket的http header发送出去的。所以普通的http抓包软件只能抓空气，想要抓我们的包，得Wireshark等这种更屌的抓包工具才行。（深深的鄙视了一眼对面的Androider）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (void)_readFrameNew;</div><div class="line">&#123;</div><div class="line">    dispatch_async(_workQueue, ^&#123;</div><div class="line">        [_currentFrameData setLength:0];        </div><div class="line">        _currentFrameOpcode = 0;</div><div class="line">        _currentFrameCount = 0;</div><div class="line">        _readOpCount = 0;</div><div class="line">        _currentStringScanPosition = 0;        </div><div class="line">        [self _readFrameContinue];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line">- (void)_readFrameContinue;</div><div class="line">&#123;</div><div class="line">    assert((_currentFrameCount == 0 &amp;&amp; _currentFrameOpcode == 0) || (_currentFrameCount &gt; 0 &amp;&amp; _currentFrameOpcode &gt; 0));</div><div class="line"></div><div class="line">    [self _addConsumerWithDataLength:2 callback:^(SRWebSocket *self, NSData *data) &#123;</div><div class="line">        __block frame_header header = &#123;0&#125;;</div><div class="line">        </div><div class="line">        const uint8_t *headerBuffer = data.bytes;</div><div class="line">        assert(data.length &gt;= 2);</div><div class="line">        </div><div class="line">        if (headerBuffer[0] &amp; SRRsvMask) &#123;</div><div class="line">            [self _closeWithProtocolError:@&quot;Server used RSV bits&quot;];</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        uint8_t receivedOpcode = (SROpCodeMask &amp; headerBuffer[0]);</div><div class="line">        </div><div class="line">        BOOL isControlFrame = (receivedOpcode == SROpCodePing || receivedOpcode == SROpCodePong || receivedOpcode == SROpCodeConnectionClose);</div><div class="line">        </div><div class="line">        if (!isControlFrame &amp;&amp; receivedOpcode != 0 &amp;&amp; self-&gt;_currentFrameCount &gt; 0) &#123;</div><div class="line">            [self _closeWithProtocolError:@&quot;all data frames after the initial data frame must have opcode 0&quot;];</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        if (receivedOpcode == 0 &amp;&amp; self-&gt;_currentFrameCount == 0) &#123;</div><div class="line">            [self _closeWithProtocolError:@&quot;cannot continue a message&quot;];</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        header.opcode = receivedOpcode == 0 ? self-&gt;_currentFrameOpcode : receivedOpcode;</div><div class="line">        </div><div class="line">        header.fin = !!(SRFinMask &amp; headerBuffer[0]);</div><div class="line">        </div><div class="line">        </div><div class="line">        header.masked = !!(SRMaskMask &amp; headerBuffer[1]);</div><div class="line">        header.payload_length = SRPayloadLenMask &amp; headerBuffer[1];</div><div class="line">        </div><div class="line">        headerBuffer = NULL;</div><div class="line">        </div><div class="line">        if (header.masked) &#123;</div><div class="line">            [self _closeWithProtocolError:@&quot;Client must receive unmasked data&quot;];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        size_t extra_bytes_needed = header.masked ? sizeof(_currentReadMaskKey) : 0;</div><div class="line">        </div><div class="line">        if (header.payload_length == 126) &#123;</div><div class="line">            extra_bytes_needed += sizeof(uint16_t);</div><div class="line">        &#125; else if (header.payload_length == 127) &#123;</div><div class="line">            extra_bytes_needed += sizeof(uint64_t);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        if (extra_bytes_needed == 0) &#123;</div><div class="line">            [self _handleFrameHeader:header curData:self-&gt;_currentFrameData];</div><div class="line">        &#125; else &#123;</div><div class="line">            [self _addConsumerWithDataLength:extra_bytes_needed callback:^(SRWebSocket *self, NSData *data) &#123;</div><div class="line">                size_t mapped_size = data.length;</div><div class="line">                #pragma unused (mapped_size)</div><div class="line">                const void *mapped_buffer = data.bytes;</div><div class="line">                size_t offset = 0;</div><div class="line">                </div><div class="line">                if (header.payload_length == 126) &#123;</div><div class="line">                    assert(mapped_size &gt;= sizeof(uint16_t));</div><div class="line">                    uint16_t newLen = EndianU16_BtoN(*(uint16_t *)(mapped_buffer));</div><div class="line">                    header.payload_length = newLen;</div><div class="line">                    offset += sizeof(uint16_t);</div><div class="line">                &#125; else if (header.payload_length == 127) &#123;</div><div class="line">                    assert(mapped_size &gt;= sizeof(uint64_t));</div><div class="line">                    header.payload_length = EndianU64_BtoN(*(uint64_t *)(mapped_buffer));</div><div class="line">                    offset += sizeof(uint64_t);</div><div class="line">                &#125; else &#123;</div><div class="line">                    assert(header.payload_length &lt; 126 &amp;&amp; header.payload_length &gt;= 0);</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                if (header.masked) &#123;</div><div class="line">                    assert(mapped_size &gt;= sizeof(_currentReadMaskOffset) + offset);</div><div class="line">                    memcpy(self-&gt;_currentReadMaskKey, ((uint8_t *)mapped_buffer) + offset, sizeof(self-&gt;_currentReadMaskKey));</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                [self _handleFrameHeader:header curData:self-&gt;_currentFrameData];</div><div class="line">            &#125; readToCurrentFrame:NO unmaskBytes:NO];</div><div class="line">        &#125;</div><div class="line">    &#125; readToCurrentFrame:NO unmaskBytes:NO];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>SocketRocket有两个“泵”方法：_pumpWriting、_pumpScanner，这两个“泵”保证了websocket数据的发送、接受功能。这两个“泵”的代码写的很不错哦，很巧妙的解决了socket数据的接收解析和发送，挺有参考意义的，毕竟人家是Facebook的。</p>
<hr>
<p>有空再继续，里面还是有很多小细节的，这些小细节的处理方法也是值得我们学习的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6455#section-5.5.1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;rfc6455 WebSockets 标准&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http
    
    </summary>
    
    
      <category term="iOS/WebSocket/SocketRocket源码" scheme="http://antyme.com/tags/iOS-WebSocket-SocketRocket%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>iOS判断当前输入法是系统自带还是第三方</title>
    <link href="http://antyme.com/2016/11/30/iOS%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E8%BE%93%E5%85%A5%E6%B3%95%E6%98%AF%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%B8%A6%E8%BF%98%E6%98%AF%E7%AC%AC%E4%B8%89%E6%96%B9/"/>
    <id>http://antyme.com/2016/11/30/iOS判断当前输入法是系统自带还是第三方/</id>
    <published>2016-11-30T03:30:07.000Z</published>
    <updated>2016-11-30T03:49:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://stackoverflow.com/questions/26153336/how-do-i-find-out-the-current-keyboard-used-on-ios8" target="_blank" rel="external">参考链接</a></p>
<p>目前iOS SDK还没有公开获取当前键盘的name，但国外大神找到了“灰色”方法可以获取到，前提是键盘处于visible活跃状态。（现在还不确定能否通过审核😅）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSString *currentKeyboardName = [[[[UITextInputMode activeInputModes] filteredArrayUsingPredicate:[NSPredicate predicateWithFormat:@&quot;isDisplayed = YES&quot;]] lastObject] valueForKey:@&quot;extendedDisplayName&quot;];</div><div class="line">if ([currentKeyboardName isEqualToString:@&quot;简体拼音&quot;] || [currentKeyboardName isEqualToString:@&quot;表情符号&quot;] || [currentKeyboardName isEqualToString:@&quot;English (US)&quot;]) &#123;</div><div class="line">//系统自带键盘</div><div class="line">&#125; else &#123;</div><div class="line">//第三方键盘 eg:百度、搜狗、讯飞等</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/26153336/how-do-i-find-out-the-current-keyboard-used-on-ios8&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://antyme.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL学习与理解</title>
    <link href="http://antyme.com/2016/09/25/OpenGL%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%90%86%E8%A7%A3/"/>
    <id>http://antyme.com/2016/09/25/OpenGL学习与理解/</id>
    <published>2016-09-25T07:41:11.000Z</published>
    <updated>2016-09-25T08:34:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素。3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线（Graphics Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。</p>
<p><img src="/images/pipeline.png" alt=""></p>
<p>首先，我们以数组的形式传递3个3D坐标作为图形渲染管线的输入，用来表示一个三角形，这个数组叫做顶点数据(Vertex Data)；顶点数据是一系列顶点的集合。一个顶点(Vertex)是一个3D坐标的数据的集合。而顶点数据是用顶点属性(Vertex Attribute)表示的，它可以包含任何我们想用的数据，但是简单起见，我们还是假定每个顶点只由一个3D位置(译注1)和一些颜色值组成的吧。</p>
<p>图形渲染管线的第一个部分是顶点着色器(Vertex Shader)，它把一个单独的顶点作为输入。顶点着色器主要的目的是把3D坐标转为另一种3D坐标（后面会解释），同时顶点着色器允许我们对顶点属性进行一些基本处理。</p>
<p>图元装配(Primitive Assembly)阶段将顶点着色器输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并所有的点装配成指定图元的形状；本节例子中是一个三角形。</p>
<p>图元装配阶段的输出会传递给几何着色器(Geometry Shader)。几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状。例子中，它生成了另一个三角形。</p>
<p>几何着色器的输出会被传入光栅化阶段(Rasterization Stage)，这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。</p>
<blockquote>
<p>OpenGL中的一个片段是OpenGL渲染一个像素所需的所有数据。</p>
</blockquote>
<p>片段着色器的主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素。3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线（Graphics Pipeline，大多译为管线，实际上指的是一
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS开发中方便好用的C语言宏</title>
    <link href="http://antyme.com/2016/08/18/C%E8%AF%AD%E8%A8%80%E5%AE%8F%E7%9A%84%E7%89%B9%E6%AE%8A%E7%94%A8%E6%B3%95%E5%92%8C%E5%87%A0%E4%B8%AA%E5%9D%91/"/>
    <id>http://antyme.com/2016/08/18/C语言宏的特殊用法和几个坑/</id>
    <published>2016-08-18T10:51:22.000Z</published>
    <updated>2016-12-08T08:08:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="宏特殊用法"><a href="#宏特殊用法" class="headerlink" title="宏特殊用法"></a>宏特殊用法</h2><h3 id="1-字符串化-Stringification"><a href="#1-字符串化-Stringification" class="headerlink" title="1. 字符串化(Stringification)"></a>1. 字符串化(Stringification)</h3><p>在宏体中，如果宏参数前加个<strong>#</strong>，那么在宏体扩展的时候，宏参数会被扩展成字符串的形式。如：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> WARN_IF(EXP) \</span></div><div class="line">do &#123; <span class="meta-keyword">if</span> (EXP) \</div><div class="line">	fprintf (stderr, <span class="meta-string">"Warning: "</span> #EXP <span class="meta-string">"\n"</span>); &#125; \</div><div class="line">while (0)</div></pre></td></tr></table></figure>
<p><strong>WARN_IF (x == 0);</strong>会被扩展成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">do </div><div class="line">&#123; </div><div class="line">	if (x == 0)</div><div class="line">		fprintf (stderr, &quot;Warning: &quot; &quot;x == 0&quot; &quot;\n&quot;); </div><div class="line">&#125;</div><div class="line">while (0);</div></pre></td></tr></table></figure>
<p>这种用法可以用在assert中，如果断言失败，可以将失败的语句输出到反馈信息中</p>
<h3 id="2-连接-Concatenation"><a href="#2-连接-Concatenation" class="headerlink" title="2. 连接(Concatenation)"></a>2. 连接(Concatenation)</h3><p>在宏体中，如果宏体所在标示符中有<strong>##</strong>，那么在宏体扩展的时候，宏参数会被直接替换到标示符中。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#define COMMAND(NAME)  &#123; #NAME, NAME ## _command &#125;</div><div class="line">struct command</div><div class="line">&#123;</div><div class="line">    char *name;</div><div class="line">    void (*function) (void);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在宏扩展的时候：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct command commands[] =</div><div class="line">&#123;</div><div class="line">    COMMAND (quit),</div><div class="line">    COMMAND (help),</div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>会被扩展成：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct command commands[] =</div><div class="line">&#123;</div><div class="line">    &#123; &quot;quit&quot;, quit_command &#125;,</div><div class="line">    &#123; &quot;help&quot;, help_command &#125;,</div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这样就节省了大量时间，提高效率。</p>
<h3 id="3-iOS中定义明确类型的模板容器"><a href="#3-iOS中定义明确类型的模板容器" class="headerlink" title="3. iOS中定义明确类型的模板容器"></a>3. iOS中定义明确类型的模板容器</h3><p>定义NSArray、NSMutableArray、NSDictionary、NSMutableDictionary等泛型容器时最好指定类型，这样不但可以充分利用Xcode的自动完成功能，提升效率，而且便于代码的维护。<br>下面的宏可以帮你快速实现这一点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#if __has_feature(objc_generics)</div><div class="line">#   define TM__GENERICS(class, ...)         class&lt;__VA_ARGS__&gt;</div><div class="line">#else</div><div class="line">#   define TM__GENERICS(class, ...)         class</div><div class="line">#endif</div><div class="line"></div><div class="line">#define TMMutableArrayWith(valueType)                   TM__GENERICS(NSMutableArray, valueType)</div><div class="line">#define TMMutableDictionaryWith(keyType, valueType)     TM__GENERICS(NSMutableDictionary, keyType, valueType)</div></pre></td></tr></table></figure>
<h3 id="未完待补充…"><a href="#未完待补充…" class="headerlink" title="未完待补充…"></a>未完待补充…</h3><hr>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;宏特殊用法&quot;&gt;&lt;a href=&quot;#宏特殊用法&quot; class=&quot;headerlink&quot; title=&quot;宏特殊用法&quot;&gt;&lt;/a&gt;宏特殊用法&lt;/h2&gt;&lt;h3 id=&quot;1-字符串化-Stringification&quot;&gt;&lt;a href=&quot;#1-字符串化-Stringificat
    
    </summary>
    
    
      <category term="c/c++" scheme="http://antyme.com/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>git好用容易忘记的命令</title>
    <link href="http://antyme.com/2016/08/18/git%E5%A5%BD%E7%94%A8%E5%AE%B9%E6%98%93%E5%BF%98%E8%AE%B0%E7%9A%84%E5%91%BD%E4%BB%A4/"/>
    <id>http://antyme.com/2016/08/18/git好用容易忘记的命令/</id>
    <published>2016-08-18T10:30:48.000Z</published>
    <updated>2018-01-20T09:15:04.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="git好用容易忘记的命令"><a href="#git好用容易忘记的命令" class="headerlink" title="git好用容易忘记的命令"></a><strong>git好用容易忘记的命令</strong></h3><p>1、移除文件</p>
<pre><code>删除本地和git跟踪：
    git rm
只删除git跟踪，保留本地：
    git rm --cached 文件名
</code></pre><p>2、移动文件</p>
<pre><code>git mv srcName dstName
相当于
mv srcName dstName
git rm srcName
git add dstName
</code></pre><p>3、查看日志</p>
<pre><code>git log
仅展示简要的增改行数统计
git log --stat
使用pretty选项适合自己风格的格式
git log --pretty=oneline
git log --pretty=short
git log --pretty=full
git log --pretty=fuller
git log --pretty=format:&quot;%h - %an, %ar : %s&quot;

format参数说明：
%H 提交对象（commit）的完整哈希字符串
%h    提交对象的简短哈希字符串
%T    树对象（tree）的完整哈希字符串
%t    树对象的简短哈希字符串
%P    父对象（parent）的完整哈希字符串
%p    父对象的简短哈希字符串
%an    作者（author）的名字
%ae    作者的电子邮件地址
%ad    作者修订日期（可以用 -date= 选项定制格式）
%ar    作者修订日期，按多久以前的方式显示
%cn    提交者（committer）的名字
%ce    提交者的电子邮箱地址
%cd    提交日期
%cr    提交日期，按多久以前的方式显示
%s    提交说明

git log常用命令选项：
-p                按补丁格式显示每个更新之间的差异
--stat            显示每次更新的文件修改统计信息
--shortstat        只显示--stat中最后的行数修改添加移除统计
--name-only        仅在提交信息后显示已修改的文件清单
--name-status    显示新增、修改、删除的文件清单
--abbrev-commit    仅显示SHA-1的前几个字符，而非所有的40个字符
--relative-date    使用较短的相对时间显示（比如，“2 week ago”）
--graph            显示ASCII图形表示的分支合并历史
--pretty        使用其他格式显示历史提交信息。可用的选项包括oneline、short、full、fuller和format（后跟指定格式）
-n                     仅显示最近的n条提交
--since, --after    仅显示指定时间之后的提交
--until, --before    仅显示指定时间之前的提交
--author            仅显示指定作者相关的提交
--committer            仅显示指定提交者相关的提交

git log --since=2.minutes
git log --since=2.weeks
git log --before=&quot;2016-08-17&quot;
git log --after=&quot;2016-08-16&quot; --before=&quot;2018-08-17&quot;
</code></pre><p>4、子模块（submodule）</p>
<pre><code>添加新的子模块
git submodule add https://github.com/chaconinc/DbConnector

存了项目 URL 与已经拉取的本地目录之间的映射
cat .gitmodules

克隆含有子模块的项目
git clone --recursive https://github.com/chaconinc/MainProject

如果你不想在子目录中手动抓取与合并，那么还有种更容易的方式。 运行命令
git submodule update --recursive --remote Git将会进入子模块然后抓取并更新。

git submodule deinit asubmodule

git rm --cached asubmodule

rm -rf .git/modules/asubmodule
</code></pre><p>5、开启socks5代理</p>
<pre><code>git config --global http.proxy &apos;socks5://127.0.0.1:1080&apos; 
git config --global https.proxy &apos;socks5://127.0.0.1:1080&apos;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;git好用容易忘记的命令&quot;&gt;&lt;a href=&quot;#git好用容易忘记的命令&quot; class=&quot;headerlink&quot; title=&quot;git好用容易忘记的命令&quot;&gt;&lt;/a&gt;&lt;strong&gt;git好用容易忘记的命令&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;1、移除文件&lt;/p&gt;
&lt;p
    
    </summary>
    
    
      <category term="git" scheme="http://antyme.com/tags/git/"/>
    
  </entry>
  
</feed>
