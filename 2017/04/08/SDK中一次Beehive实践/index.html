<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Beehive源码简析 · bug world</title><meta name="description" content="Beehive源码简析 - bug小英雄"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://antyme.com/atom.xml" title="bug world"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.jpeg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/cosmos180" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Beehive源码简析</h1><div class="post-info">2017年4月8日</div><div class="post-content"><p>参考链接：</p>
<p><a href="https://github.com/alibaba/BeeHive" target="_blank" rel="external">alibaba/BeeHive</a></p>
<p><a href="https://halfrost.com/beehive/" target="_blank" rel="external">BeeHive —— 一个优雅但还在完善中的解耦框架</a></p>
<h3 id="BeeHive概述"><a href="#BeeHive概述" class="headerlink" title="BeeHive概述"></a>BeeHive概述</h3><p><img src="/images/beehive.png" alt=""></p>
<p>BeeHive是用于iOS的App模块化编程的框架实现方案，吸收了Spring框架Service的理念来实现模块间的API耦合。</p>
<p>目前BeeHive v1.2.0 全部是利用Protocol的方式，实现了模块间解耦的目的：</p>
<ol>
<li>各个模块以插件的形式存在。每个都可独立，相互解耦。 </li>
<li>各个模块具体实现与接口调用分离 </li>
<li>各个模块也有生命周期，也可以进行管理。</li>
</ol>
<h3 id="BeeHive模块注册"><a href="#BeeHive模块注册" class="headerlink" title="BeeHive模块注册"></a>BeeHive模块注册</h3><p>先从模块的注册开始分析，来看看BeeHive是如何给各个模块进行注册的。</p>
<p>在BeeHive中是通过BHModuleManager来管理各个模块的。BHModuleManager中只会管理已经被注册过的模块。</p>
<p>注册Module的方式总共有三种：</p>
<h5 id="Annotation方式注册"><a href="#Annotation方式注册" class="headerlink" title="Annotation方式注册"></a>Annotation方式注册</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BeeHiveService(HomeServiceProtocol,BHViewController)</div></pre></td></tr></table></figure>
<p>BeeHiveService宏定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#define BeeHiveService(servicename,impl) \</div><div class="line">char * k##servicename##_service BeeHiveDATA(BeehiveServices) = &quot;&#123; \&quot;&quot;#servicename&quot;\&quot; : \&quot;&quot;#impl&quot;\&quot;&#125;&quot;;</div></pre></td></tr></table></figure>
<p>BeeHiveDATA又是一个宏：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define BeeHiveDATA(sectname) __attribute((used, section(&quot;__DATA,&quot;#sectname&quot; &quot;)))</div></pre></td></tr></table></figure>
<p>最终BeeHiveService宏会在预编译结束会完全展开成下面的样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">char * kHomeServiceProtocol_service __attribute((used, section(&quot;__DATA,&quot;&quot;BeehiveServices&quot;&quot; &quot;))) = &quot;&#123; \&quot;&quot;&quot;HomeServiceProtocol&quot;&quot;\&quot; : \&quot;&quot;&quot;BHViewController&quot;&quot;\&quot;&#125;&quot;;</div></pre></td></tr></table></figure>
<p>到这里__attribute((used,section(“segmentname,sectionname”)))就需要先说明2个地方。</p>
<p>__attribute第一个参数used很有用。这个关键字是用来修饰函数的。被used修饰以后，意味着即使函数没有被引用，在Release下也不会被优化。如果不加这个修饰，那么Release环境链接器下会去掉没有被引用的段。具体的描述可以看这个gun的<a href="https://gcc.gnu.org/onlinedocs/gcc-3.2/gcc/Variable-Attributes.html" target="_blank" rel="external">官方文档</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">section (&quot;section-name&quot;)</div><div class="line">Normally, the compiler places the objects it generates in sections like data and bss. Sometimes, however, you need additional sections, or you need certain particular variables to appear in special sections, for example to map to special hardware. The section attribute specifies that a variable (or function) lives in a particular section. For example, this small program uses several specific section names:</div><div class="line">          struct duart a __attribute__ ((section (&quot;DUART_A&quot;))) = &#123; 0 &#125;;</div><div class="line">          struct duart b __attribute__ ((section (&quot;DUART_B&quot;))) = &#123; 0 &#125;;</div><div class="line">          char stack[10000] __attribute__ ((section (&quot;STACK&quot;))) = &#123; 0 &#125;;</div><div class="line">          int init_data __attribute__ ((section (&quot;INITDATA&quot;))) = 0;</div><div class="line">          </div><div class="line">          main()</div><div class="line">          &#123;</div><div class="line">            /* Initialize stack pointer */</div><div class="line">            init_sp (stack + sizeof (stack));</div><div class="line">          </div><div class="line">            /* Initialize initialized data */</div><div class="line">            memcpy (&amp;init_data, &amp;data, &amp;edata - &amp;data);</div><div class="line">          </div><div class="line">            /* Turn on the serial ports */</div><div class="line">            init_duart (&amp;a);</div><div class="line">            init_duart (&amp;b);</div><div class="line">          &#125;</div><div class="line">          </div><div class="line">Use the section attribute with an initialized definition of a global variable, as shown in the example. GCC issues a warning and otherwise ignores the section attribute in uninitialized variable declarations.</div><div class="line"></div><div class="line">You may only use the section attribute with a fully initialized global definition because of the way linkers work. The linker requires each object be defined once, with the exception that uninitialized variables tentatively go in the common (or bss) section and can be multiply &quot;defined&quot;. You can force a variable to be initialized with the -fno-common flag or the nocommon attribute.</div><div class="line"></div><div class="line">Some file formats do not support arbitrary sections so the section attribute is not available on all platforms. If you need to map the entire contents of a module to a particular section, consider using the facilities of the linker instead.</div></pre></td></tr></table></figure>
<p>Static静态变量会按照他们申明的顺序，放到一个单独的段中。我们通过使用<strong>attribute</strong>((section(“name”)))来指明哪个段。数据则用<strong>attribute</strong>((used))来标记，防止链接器会优化删除未被使用的段。</p>
<p>再来具体说说section的作用。</p>
<p>编译器编译源代码后生成的文件叫目标文件，从文件结构上来说，它已经是编译后可执行的文件格式，只是还没有经过链接的过程。可执行文件(Executable)主要是Windows下的PE(Portable Executable)和Linux的ELF(Executable Linkable Format)，它们也都是COFF(Common file format)格式的变种。程序源程序代码被编译之后会主要分成两个段：程序指令和程序数据。代码段属于程序指令，数据段和.bss段属于数据段。</p>
<p>可执行文件结构图：</p>
<p><img src="/images/elf.png" alt=""></p>
<p>Module被这样存到了特殊的段中，那怎么取出来的呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">static NSArray&lt;NSString *&gt;* BHReadConfiguration(char *section)  </div><div class="line">&#123;</div><div class="line">    NSMutableArray *configs = [NSMutableArray array];</div><div class="line"></div><div class="line">    Dl_info info;</div><div class="line">    dladdr(BHReadConfiguration, &amp;info);</div><div class="line"></div><div class="line">#ifndef __LP64__</div><div class="line">    // const struct mach_header *mhp = _dyld_get_image_header(0); // both works as below line</div><div class="line">    const struct mach_header *mhp = (struct mach_header*)info.dli_fbase;</div><div class="line">    unsigned long size = 0;</div><div class="line">    // 找到之前存储的数据段(Module找BeehiveMods段 和 Service找BeehiveServices段)的一片内存</div><div class="line">    uint32_t *memory = (uint32_t*)getsectiondata(mhp, &quot;__DATA&quot;, section, &amp; size);</div><div class="line">#else /* defined(__LP64__) */</div><div class="line">    const struct mach_header_64 *mhp = (struct mach_header_64*)info.dli_fbase;</div><div class="line">    unsigned long size = 0;</div><div class="line">    uint64_t *memory = (uint64_t*)getsectiondata(mhp, &quot;__DATA&quot;, section, &amp; size);</div><div class="line">#endif /* defined(__LP64__) */</div><div class="line"></div><div class="line">    // 把特殊段里面的数据都转换成字符串存入数组中</div><div class="line">    for(int idx = 0; idx &lt; size/sizeof(void*); ++idx)&#123;</div><div class="line">        char *string = (char*)memory[idx];</div><div class="line"></div><div class="line">        NSString *str = [NSString stringWithUTF8String:string];</div><div class="line">        if(!str)continue;</div><div class="line"></div><div class="line">        BHLog(@&quot;config = %@&quot;, str);</div><div class="line">        if(str) [configs addObject:str];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return configs;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过调用这个static函数BHReadConfiguration，我们就可以拿到之前注册到BeehiveMods特殊段里面的各个Module的类名，都用字符串装在数据里。</p>
<h5 id="读取本地Pilst文件"><a href="#读取本地Pilst文件" class="headerlink" title="读取本地Pilst文件"></a>读取本地Pilst文件</h5><p>要读取本地的Plist文件之前，需要先设置好路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[BHContext shareInstance].moduleConfigName = @&quot;BeeHive.bundle/BeeHive&quot;;</div></pre></td></tr></table></figure></p>
<p><img src="/images/plist.png" alt=""></p>
<h5 id="Load方法注册"><a href="#Load方法注册" class="headerlink" title="Load方法注册"></a>Load方法注册</h5><p>最后一种注册Module的方法就是在Load方法里面注册Module的类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">+ (void)load</div><div class="line">&#123;</div><div class="line">    [BeeHive registerDynamicModule:[self class]];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)registerService:(Protocol *)service implClass:(Class)implClass</div><div class="line">&#123;</div><div class="line">    NSParameterAssert(service != nil);</div><div class="line">    NSParameterAssert(implClass != nil);</div><div class="line"></div><div class="line">    // impClass 是否遵循了 Protocol 协议</div><div class="line">    if (![implClass conformsToProtocol:service] &amp;&amp; self.enableException) &#123;</div><div class="line">        @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:[NSString stringWithFormat:@&quot;%@ module does not comply with %@ protocol&quot;, NSStringFromClass(implClass), NSStringFromProtocol(service)] userInfo:nil];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Protocol 协议是否已经注册过了</div><div class="line">    if ([self checkValidService:service] &amp;&amp; self.enableException) &#123;</div><div class="line">        @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:[NSString stringWithFormat:@&quot;%@ protocol has been registed&quot;, NSStringFromProtocol(service)] userInfo:nil];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    NSMutableDictionary *serviceInfo = [NSMutableDictionary dictionary];</div><div class="line">    [serviceInfo setObject:NSStringFromProtocol(service) forKey:kService];</div><div class="line">    [serviceInfo setObject:NSStringFromClass(implClass) forKey:kImpl];</div><div class="line"></div><div class="line">    [self.lock lock];</div><div class="line">    [self.allServices addObject:serviceInfo];</div><div class="line">    [self.lock unlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="BeeHive模块调用"><a href="#BeeHive模块调用" class="headerlink" title="BeeHive模块调用"></a>BeeHive模块调用</h3><p>在BeeHive中调用以下方法可以返回一个能相应Protocol的实例对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">- (id)createService:(Protocol *)proto;</div><div class="line"></div><div class="line">- (id)createService:(Protocol *)proto;</div><div class="line">&#123;</div><div class="line">    return [[BHServiceManager sharedManager] createService:proto];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)createService:(Protocol *)service</div><div class="line">&#123;</div><div class="line">    id implInstance = nil;</div><div class="line"></div><div class="line">    // Protocol 协议是否已经注册过了</div><div class="line">    if (![self checkValidService:service] &amp;&amp; self.enableException) &#123;</div><div class="line">        @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:[NSString stringWithFormat:@&quot;%@ protocol does not been registed&quot;, NSStringFromProtocol(service)] userInfo:nil];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Class implClass = [self serviceImplClass:service];</div><div class="line"></div><div class="line">    if ([[implClass class] respondsToSelector:@selector(shareInstance)])</div><div class="line">        implInstance = [[implClass class] shareInstance];</div><div class="line">    else</div><div class="line">        implInstance = [[implClass alloc] init];</div><div class="line"></div><div class="line">    if (![implInstance respondsToSelector:@selector(singleton)]) &#123;</div><div class="line">        return implInstance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    NSString *serviceStr = NSStringFromProtocol(service);</div><div class="line"></div><div class="line">    // 是否需要缓存</div><div class="line">    if ([implInstance singleton]) &#123;</div><div class="line">        id protocol = [[BHContext shareInstance] getServiceInstanceFromServiceName:serviceStr];</div><div class="line"></div><div class="line">        if (protocol) &#123;</div><div class="line">            return protocol;</div><div class="line">        &#125; else &#123;</div><div class="line">            [[BHContext shareInstance] addServiceWithImplInstance:implInstance serviceName:serviceStr];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125; else &#123;</div><div class="line">        [[BHContext shareInstance] addServiceWithImplInstance:implInstance serviceName:serviceStr];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return implInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法也会先检查Protocol协议是否是注册过的。然后接着取出字典里面对应的Class，如果实现了shareInstance方法，那么就生成一个单例出来，如果没有，那么就随便生成一个对象出来。如果还实现了singleton，就能进一步的把implInstance和serviceStr对应的加到BHContext的servicesByName字典里面缓存起来。这样就可以随着上下文传递了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通常会有三种形式的接口访问形式：</p>
<ul>
<li>基于接口的实现Service访问方式（Java spring框架实现）</li>
<li>基于函数调用约定实现的Export Method(PHP的extension，ReactNative的扩展机制)</li>
<li>基于跨应用实现的URL Route模式(iPhone App之间的互访)</li>
</ul>
<p>BeeHive目前只实现了第一种方式，后两种方式还需要继续完善。</p>
<p>基于接口Service访问的优点是可以编译时检查发现接口的变更，从而及时修正接口问题。缺点是需要依赖接口定义的头文件，通过模块增加得越多，维护接口定义的也有一定工作量。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/04/07/iOS-SDK-cocoapod实践：源码管理和二进制发布/" class="prev">PREV</a><a href="/2017/04/17/iOS图形对象理解/" class="next">NEXT</a></div><div data-thread-key="2017/04/08/SDK中一次Beehive实践/" data-title="Beehive源码简析" data-url="http://antyme.com/2017/04/08/SDK中一次Beehive实践/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"antyme"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2012 - 2018 <a href="http://antyme.com">bug小英雄</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>